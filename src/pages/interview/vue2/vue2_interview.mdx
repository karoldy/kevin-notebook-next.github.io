# Vue2 面试题

## 面试官系列

- [有使用过vue吗?说说你对vue的理解?](/interview/vue2/vue)
- [你对SPA单页面的理解, 它的优缺点分别是什么?如何实现SPA应用呢?](/interview/vue2/spa)
- [v-show和v-if有什么区别?使用场景分别是什么?](/interview/vue2/show_if)
- [Vue实例挂载的过程?](/interview/vue2/new_vue)
- [请描述下你对vue生命周期的理解?在created和mounted这两个生命周期中请求数据有什么区别呢?](/interview/vue2/lifecycle)
- [v-if和v-for的优先级是什么?](/interview/vue2/if_for)
- [SPA首屏加载速度慢的怎么解决?](/interview/vue2/first_page_time)
- [为什么data属性是一个函数而不是一个对象?](/interview/vue2/data)
- [动态给vue的data添加一个新的属性时会发生什么?怎样解决?](/interview/vue2/data_object_add_attrs)
- [Vue中组件和插件有什么区别?](/interview/vue2/components_plugin)
- [Vue组件之间的通信方式都有哪些?](/interview/vue2/communication)
- [双向数据绑定是什么?](/interview/vue2/bind)
- [Vue中的$nextTick有什么作用?](/interview/vue2/nexttick)
- [说说你对vue的mixin的理解, 有什么应用场景?](/interview/vue2/mixin)
- [说说你对slot的理解?slot使用场景有哪些?](/interview/vue2/slot)
- [Vue.observable你有了解过吗?说说看?](/interview/vue2/observable)
- [你知道vue中key的原理吗?说说你对它的理解?](/interview/vue2/key)
- [说说你对keep-alive的理解是什么?](/interview/vue2/keepalive)
- [Vue常用的修饰符有哪些有什么应用场景?](/interview/vue2/modifier)
- [你有写过自定义指令吗?自定义指令的应用场景有哪些?](/interview/vue2/directive)
- [Vue中的过滤器了解吗?过滤器的应用场景有哪些?](/interview/vue2/filter)
- [什么是虚拟DOM?如何实现一个虚拟DOM?说说你的思路?](/interview/vue2/vnode)
- [你了解vue的diff算法吗?说说看?](/interview/vue2/diff)
- [Vue项目中有封装过axios吗?主要是封装哪方面的?](/interview/vue2/axios)
- [你了解axios的原理吗?有看过它的源码吗?](/interview/vue2/axiosCode)
- [SSR解决了什么问题?有做过SSR吗?你是怎么做的?](/interview/vue2/ssr)
- [说下你的vue项目的目录结构, 如果是大型项目你该怎么划分结构和划分组件呢?](/interview/vue2/structure)
- [vue要做权限管理该怎么做?如果控制到按钮级别的权限怎么做?](/interview/vue2/permission)
- [Vue项目中你是如何解决跨域的呢?](/interview/vue2/cors)
- [vue项目本地开发完成后部署到服务器后报404是什么原因呢?](/interview/vue2/v_404)
- [你是怎么处理vue项目中的错误的?](/interview/vue2/error)
- [vue3有了解过吗?能说说跟vue2的区别吗?](/interview/vue2/vue3_vue2)

## 经典面试题

### 1.MVVM框架的理解

**MVVM**是**Model-View-ViewModel**的简写。即【模型】-【视图】-【视图模型】

- 【模型】(Model): 指的是后端传递的数据
- 【视图】(View): 指的是所看到的页面
- 【视图模型】(ViewModel): mvvm模式的核心, 它是连接view和model的桥梁。

**视图模型有两个方向**: 

一是将【模型】转化成【视图】, 即将后端传递的数据转化成所看到的页面。实现的方式是数据绑定。

二是将【视图】转化成【模型】, 即将所看到的页面转化成后端的数据。实现的方式是: DOM事件监听。

这两个方向都实现的, 我们称之为数据的双向绑定。

**总结**: 

在MVVM的框架下视图和模型是不能直接通信的。它们通过viewModel来通信, ViewModel通常要实现一个observer观察者, 当数据发生变化, ViewModel能够监听到数据的这种变化, 然后通知到对应的视图做自动更新, 而用户操作视图, ViewModel也能监听到视图的变化, 然后通知数据做改动, 这实际上就实现了数据的双向绑定。并且MVVM中的view和ViewModel可以互相通信。

>Vue就是基于MVVM实现的一套框架, 在vue中, 【模型】指的是JavaScript中的数据, 如对象, 数组等。【视图】指的是页面视图。【视图模型】指的是vue的实例化对象。

>Vue最独特的特性: 响应式系统。vue是响应式的, 也就是说当我们的数据变更时, vue会帮你更新所有网页中用到它的地方。关于这个响应式原理, 官方已经讲得很清楚, [请参考](https://cn.vuejs.org/v2/guide/Reactivity.html)

---

### 2.如何理解Vue是一套渐进式的框架

渐进式是什么意思?

1. 如果你有一个现成的服务端应用, 你可以将vue作为该应用的一部分嵌入其中, 带来更加丰富的交互体验
2. 如果你希望将更多业务逻辑放到前端来实现, 那么vue的核心库及其生态系统也可以满足你的各式需求(core+vuex+vue-router)。和其他前端框架一样, vue允许你将一个网页分割成可复用的组件, 每个组件包含属于自己的Html、css。JavaScript用来渲染网页中相应的地方。
3. 如果我们构建一个大型的应用, 在这一点上, 我们可能需要将东西分割成各自的组件和文件, vue有一个命令行工具, 使快速初始化一个真实的工程变得非常简单。我们可以用vue的单文件组件, 它包含了各自的Html、Css、JavaScript以及带作用域的Css或者Scss。

以上三个例子, 是一步步递进的, 也就是说对Vue的使用可大可小, 它都会有相应的方式整合到你的项目中。所以说它是一个渐进式的框架。

---

### 3.v-on可以监听多个方法吗

可以

1. 使用`v-on="{ method1(), method2()}"`的方式, 这种方式可以在同一个元素上绑定多个方法。
2. 另一种高级用法是将所有需要传递给子组件的事件函数存储在一个数组中, 然后在子组件中使用`v-on="$listener"`的方式来注册这些方法。

---

### 4.vue中key的作用?为什么不推介使用index作为key?

**key 的特殊属性主要用在 Vue的虚拟DOM算法, 在新旧nodes对比时辨识VNodes。**

如果不使用key, Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。

使用key, 它会基于key的变化重新排列元素顺序, 并且会移除key不存在的元素

1. key的作用主要是为了高效的更新虚拟DOM(使用key, 它会基于key的变化重新排列元素顺序, 并且会移除key不存在的元素)

2. 当以数组的下标index作为index值时, 其中一个元素(如增删改查)发生了变化就有可能导致所有元素的key值发生变化

---

### 5.vue事件中如何使用event对象

vue传递事件对象 `$event` 

有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 `$event` 把它传入方法

例子: 

```vue showLineNumbers copy
<template>
  <a href="javascript:;" data-id="1" @click="clickEvent($event)">event</a>
</template>

<script>
export default {
  methods: {
    clickEvent(event){
      // 获取data-id
      console.log(event.target.dataset.id)
      // 阻止事件冒泡
      event.stopPropagation()
    }
  }
}
</script>
```

### 6.computed和watch区别

**computed的特点**

- 支持缓存, 默认走缓存, 多次调用, 只会执行一次计算。只有依赖的数据发生改变, 才会重新计算
- 不支持异步, 如果有异步操作, 无法监听
- 属性值为函数, 默认使用get方法, 当数据改变时, 会调用set方法
- 主要解决模版中放入过多的逻辑导致不好维护的问题

**watch的特点**

- 不支持缓存, 只要数据发生变化, 就会触发相应的操作;
- 支持异步监听;
- 接收两个参数, 第一个是最新值, 第二个是之前的值;
- 还有两个其他参数: deep: 默认false, 深度监听, immediate: 默认false, 初始化时执行回调函数;

**总结**

- computed计算属性, 他依赖其他属性值, 有缓存, 只有依赖的值发生变化才会去重新计算, 但是不能异步;
- watch监听, 监听数据的变化, 无缓存, 数据变化就会执行回调, 可以异步;

**使用场景**

- 当一个值受多个属性影响的时候使用computed
- 当一条数据的更改影响到多条数据的时候使用watch

[计算属性computed和watch监视的使用和区别](/vue/vue2/vue_2)

---

### 7.Object.defineProperty 和 proxy的区别

1. `Object.defineProperty`只能劫持对象的属性, 需要遍历对象的每个属性, 如果属性值也是对象, 则需要深度遍历, 而proxy是直接代理对象, 不需要遍历操作
2. `Object.defineProperty`对新增属性需要手动进行observe, 因为defineproperty劫持的是对象的属性, 所以新增属性时, 需要重新遍历对象, 再对新增属性再使用defineproperty进行劫持。而proxy可以直接监听对象属性的添加

也是因为这个原因, vue2.0在给data中的数组或对象新增属性时, 需要用vm.$set来保证新增属性的响应

**简单的说**

definedProperty的缺陷

- 不能监听数组变化
- 必须遍历对象的每个属性
- 必须深层遍历嵌套对象

**proxy对比definedProperty的优点**

- proxy监听的是整个对象而不是对象的某个属性
- proxy可以监听数组的变化
- proxy结果返回一个新的对象, 可以直接操作新对象, 而不是像definedproperty遍历属性进行修改
- proxy相对性能更好
- proxy对浏览器的兼容性不够

---

### 8. vue props如何自定义验证

```js showLineNumbers copy showLineNumbers copy
export default {
  props: {
    num: {
      default: 1,
      validator: function(value) {
        // 返回false则验证不通过, 报错 
        return value <= 2;
      }  
    }
  }
}
```

---

### 9.如何让CSS只在当前组件中起作用

Vue可以通过使用scoped属性来限制样式仅应用于特定的组件。

在单文件组件(.vue)中, 将style标签添加scoped属性, 示例如下所示: 

```vue showLineNumbers copy
<template>
  <!-- 模板内容 -->
</template>
 
<script>
export default {
  // 组件逻辑
}
</script>
 
<style scoped>
/* CSS样式 */
</style>
```

这样设置后, 该组件的CSS样式就会被局部化, 不会影响其他组件或全局样式。

---

### 10.相同路由组件如何重新渲染

Vue默认不会对相同的路由的切换做重新渲染

如果需要重新渲染, 可以添加key

```vue showLineNumbers copy
<template>
  <router-view :key="$route.path"></router-view>
</tempalte>
```

---

### 11.如何获取data某个数值的初始值

data的属性改变后, 可以通过`this.$options.data().x` 获取初始值

---

### 12.v-model语法糖是怎么实现的

`v-model`是`value` + `input`的语法糖, 是`v-band`和`v-on`的简洁写法。`v-model`就实现了双向数据绑定, 实际上它就是通过Vue提供的事件机制。即在子组件通过`$emit()`触发一个事件, 在父组件使用`v-model`即可

---

### 13.Vue中如何获取dom、操作dom、更新dom

在Vue中, 可以通过ref属性来获取DOM元素。首先需要为目标DOM元素添加ref属性, 然后使用this.$refs.xxx来访问该DOM元素。

示例代码如下所示: 

```vue showLineNumbers copy
<template>
  <div ref="myDiv">Hello Vue!</div>
</template>
 
<script>
export default {
  mounted() {
    // 获取DOM元素
    const myElement = this.$refs.myDiv;
    
    // 对DOM进行操作
    myElement.style.color = 'red';
  
    // 更新DOM内容
    myElement.innerText = 'Updated DOM content';
  }
}
</script>
```

---

### 14.在Vue中, 子组件为何不可以修改父组件传递的Prop

Vue提倡单向数据流,即父级props的更新会流向子组件,但是反过来则不行。这是为了防止意外的改变父组件状态, 使得应用的数据流变得难以理解。如果破坏了单向数据流, 当应用复杂时, debug 的成本会非常高。

---

### 15.双向绑定和vuex是否冲突

双向绑定和Vuex并不直接冲突, 但在某些情况下可能会引起一些问题。

双向绑定是指视图(View)和模型(Model)之间的双向数据绑定, 当视图中的数据发生变化时, 模型会随之更新;反过来, 当模型中的数据发生变化时, 视图也会相应地更新。在Vue中, 通过`v-model`指令可以实现双向数据绑定。

Vuex是Vue的状态管理库, 用于集中管理应用程序的状态。它提供了一个单一的、可预测的状态树, 并通过mutation和action来修改和管理状态。Vuex的核心思想是通过单向数据流来管理状态, 即从状态树到视图的单向数据流。

在使用Vuex时, 可以将状态存储在Vuex的状态树中, 并通过getter获取状态, 通过mutation来修改状态。这种方式可以保持状态的一致性和可追踪性, 避免了多个组件直接修改共享状态的问题。

然而, 当双向绑定和Vuex同时使用时, 可能会引起一些问题。双向绑定可能导致视图直接修改了Vuex中的状态, 而绕过了Vuex的mutation, 这可能破坏了状态的可预测性和一致性。另外, 在大型应用中, 双向绑定可能导致状态的变更难以追踪和调试。

为了避免这些问题, 通常建议在使用Vuex时尽量避免直接在组件中使用双向绑定。相反, 通过使用Vuex的getter来获取状态, 在组件中使用单向数据流来更新视图。如果需要在组件中修改状态, 应该使用Vuex的mutation或action来进行, 以保持状态管理的一致性和可追踪性。

---

### 16.Vue的父组件和子组件生命周期钩子执行顺序是什么

**加载渲染过程**

`父beforeCreate` --> `父created` --> `父beforeMount` --> `子beforeCreate` --> `子created` --> `子beforeMount` -->` 子Mounted` --> `父Mounted`

**子组件更新过程**

`父beforeUpdate` --> `子beforeUpdate` --> `子updated` --> `父updated`

**父组件更新过程**

`父beforeUpdate` --> `父updated`

**销毁过程**

`父beforeDestory` --> `子beforeDestory` --> `子destoryed` --> `父destoryed`

---

### 17.第一次页面加载会触发哪几个钩子

第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子

---

### 18.请说出vue.cli项目中src目录每个文件夹和文件的用法?

- assets: 文件夹是放静态资源
- components: 是放组件
- router: 是定义路由相关的配置 
- app.vue: 是一个应用主组件
- main.js: 是入口文件

---

### 19.vue-loader是什么?使用它的用途有哪些?

- 解析.vue文件: vue-loader可以解析.vue文件中的模板、样式和脚本, 并将它们分离出来进行处理
- 支持单文件组件的开发方式: 通过vue-loader, 可以使用单文件组件的方式来开发Vue.js应用, 将模板、样式和脚本组织在一个文件中, 使代码更加清晰和易于维护
- 热重载: vue-loader支持热重载功能, 即在开发过程中对.vue文件的修改会立即反映在浏览器中, 无需手动刷新页面
- 预处理器支持: vue-loader支持各种预处理器, 如Sass、Less和Stylus, 可以在.vue文件中使用这些预处理器语言来编写样式

---

### 在使用计算属性的时, 函数名和data数据源中的数据可以同名吗?

正确顺序:props、methods、data、computed、watch

```
莫名其妙的问题。可以同名, 但data会覆盖methods。并且本就不该同名, 同名说明你命名不规范。
然后解释为什么会覆盖, 因为Props、methods、data、computed、watch都是在initState函数中被初始化的。初始化顺序就是我上面给出的顺序, 本质上这些都是要挂载到this上面的, 你如果重名的话, 后面出现的属性自然而然会覆盖之前挂载的属性了。如果你的eslint配置比较严格的话, 同名是编译不通过的。

不可以, 因为初始化vm的过程, 会先把data绑定到vm,再把computed的值绑定到vm, 会把data覆盖了
```

---