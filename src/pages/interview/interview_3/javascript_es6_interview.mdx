# JavaScript Es6 面试题

## 1.var、 let 、const 区别?（常问、必记）

**1. `var`**

作用域: var声明的变量拥有函数作用域，如果在函数外部声明，它将具有全局作用域。在全局作用域下使用var声明的变量会被附加到**window对象**上。

- **变量提升**: var声明的变量会发生变量提升（hoisting），意味着无论在函数的哪个部分声明，它们都会被移动到函数的顶部。
- **重复声明**: 使用var可以重复声明同一个变量。
- **重新赋值**: 使用var声明的变量可以被重新赋值。

**2. `let`**

- **作用域**: let声明的变量具有块级作用域（block scope），仅在声明它的代码块内有效。
- **变量提升**: let声明的变量也会提升，但它们不会被初始化。在代码执行到声明之前，它们是不可访问的，这个区间被称为“暂时性死区”（Temporal Dead Zone, TDZ）。
- **重复声明**: 在同一个作用域中，let不允许重新声明已经存在的变量。
- **重新赋值**: 使用let声明的变量可以被重新赋值，但不能重复声明。

**3. `const`**

- **作用域**: 与let相同，const声明的变量也具有块级作用域。
- **变量提升**: const同样会提升到块的顶部，但是在声明语句之前它们也是不可访问的，存在于**暂时性死区**中。
- **重复声明**: const不允许在相同作用域内重复声明变量。
- **重新赋值**: const声明的变量不能被重新赋值，它们必须在声明时初始化，并且声明后值是固定的。但是，如果const变量指向的是一个对象或数组，那么对象或数组的内容是可以被修改的。

**附加在window对象上**

>在浏览器环境中，全局作用域下使用var声明的变量会成为window对象的属性。这意味着，如果你声明了var dog = 'bowser'，实际上你添加了一个新的全局变量dog到window对象上，你可以通过window.dog访问到它，并且会得到'bowser'这个值。相比之下，let和const声明的变量则不会被添加到window对象。这有助于避免全局命名空间的污染，也让变量的控制范围更加严格。

**暂时性死区**

只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

```js showLineNumbers copy
var tmp = 123;

if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}
```

上面代码中，存在全局变量`tmp`，但是块级作用域内`let`又声明了一个局部变量`tmp`，导致后者绑定这个块级作用域，所以在`let`声明变量前，对tmp赋值会报错。

ES6 明确规定，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

总之，在代码块内，使用`let`命令声明变量之前，该变量都是不可用的。这在语法上，称为**暂时性死区**（temporal dead zone，简称 TDZ）。

```js showLineNumbers copy
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
```

上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。

“暂时性死区”也意味着`typeof`不再是一个百分之百安全的操作。

```js showLineNumbers copy
typeof x; // ReferenceError
let x;
```

上面代码中，变量`x`使用`let`命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，`typeof`运行时就会抛出一个`ReferenceError`。

作为比较，如果一个变量根本没有被声明，使用`typeof`反而不会报错。

```js showLineNumbers copy
typeof undeclared_variable // "undefined"
```

上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。

有些“死区”比较隐蔽，不太容易发现。

```js showLineNumbers copy
function bar(x = y, y = 2) {
  return [x, y];
}

bar(); // 报错
```

上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。

```js showLineNumbers copy
function bar(x = 2, y = x) {
  return [x, y];
}
bar(); // [2, 2]
```

另外，下面的代码也会报错，与var的行为不同。

```js showLineNumbers copy
// 不报错
var x = x;

// 报错
let x = x;
// ReferenceError: x is not defined
```

上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。

ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。

总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

---

## 2.ES6中数组新增了哪些扩展？

**扩展运算符的应用**

ES6通过扩展元素符...，好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列

```js showLineNumbers copy
console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll('div')]
// [<div>, <div>, <div>]
```

>注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组

---

## 3.你是怎么理解ES6新增Set、Map两种数据结构的？

Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构

- 集合: 是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合
- 字典: 是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同

**区别？**

- 共同点：集合、字典都可以存储不重复的值
- 不同点：集合是以`[值，值]`的形式存储元素，字典是以`[键，值]`的形式存储

---

