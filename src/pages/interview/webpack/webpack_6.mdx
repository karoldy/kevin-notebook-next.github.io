# 说说webpack的热更新是如何做到的?原理是什么?

## 是什么

`HMR`全称 `Hot Module Replacement`, 可以理解为模块热替换, 指在应用程序运行过程中, 替换、添加、删除模块, 而无需重新刷新整个应用

例如, 我们在应用运行过程中修改了某个模块, 通过自动刷新会导致整个应用的整体刷新, 那页面中的状态信息都会丢失

如果使用的是 `HMR`, 就可以实现只将修改的模块实时替换至应用中, 不必完全刷新整个应用

在webpack中配置开启热模块也非常的简单, 如下代码: 

```js showLineNumbers copy
const webpack = require('webpack')
module.exports = {
  // ...
  devServer: {
    // 开启 HMR 特性
    hot: true
    // hotOnly: true
  }
}
```

通过上述这种配置, 如果我们修改并保存css文件, 确实能够以不刷新的形式更新到页面中

但是, 当我们修改并保存js文件之后, 页面依旧自动刷新了, 这里并没有触发热模块

所以, HMR并不像 Webpack 的其他特性一样可以开箱即用, 需要有一些额外的操作

我们需要去指定哪些模块发生更新时进行HRM, 如下代码: 

```js showLineNumbers copy
if(module.hot){
  module.hot.accept('./util.js',()=>{
    console.log("util.js更新了")
  })
}
```

## 实现原理

Webpack的热更新是通过webpack-dev-server实现的。当代码发生变化时, webpack-dev-server会将变化的部分打包成一个补丁文件（chunk）并发送到浏览器端, 浏览器端会根据这个补丁文件进行局部更新, 而不是重新加载整个页面。

具体的原理如下: 

1. `webpack-dev-server`启动一个`WebSocket`服务器, 与浏览器建立连接。
2. `webpack-dev-server`在打包的时候, 会将需要热更新的模块打包成一个独立的`chunk`, 并将该`chunk`的`hash`值保存在内存中。
3. 当代码发生变化时, `webpack`会重新编译代码, 并生成一个新的`chunk`, 该`chunk`的`hash`值与上一次保存的hash`值不同。
4. `webpack-dev-server`会将新的`hash`值发送到浏览器端, 浏览器端通过`WebSocket`接收到该hash值。
5. 浏览器端通过`XMLHttpRequest`或者`JSONP`向`webpack-dev-server`发起请求, 请求该`hash`值对应的`chunk`文件。
6. `webpack-dev-server`会将该`chunk`文件发送到浏览器端, 并通过`WebSocket`告诉浏览器端哪些模块发生了变化。
7. 浏览器端根据这些信息进行局部更新。
