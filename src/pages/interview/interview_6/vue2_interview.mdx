# Vue2 面试题

## MVVM框架的理解

**MVVM**是**Model-View-ViewModel**的简写。即【模型】-【视图】-【视图模型】

- 【模型】(Model)：指的是后端传递的数据
- 【视图】(View)：指的是所看到的页面
- 【视图模型】(ViewModel)：mvvm模式的核心，它是连接view和model的桥梁。

**视图模型有两个方向：**

一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是数据绑定。

二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM事件监听。

这两个方向都实现的，我们称之为数据的双向绑定。

**总结：**

在MVVM的框架下视图和模型是不能直接通信的。它们通过viewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的view和ViewModel可以互相通信。

>Vue就是基于MVVM实现的一套框架，在vue中，【模型】指的是JavaScript中的数据，如对象，数组等。【视图】指的是页面视图。【视图模型】指的是vue的实例化对象。

>Vue最独特的特性：响应式系统。vue是响应式的，也就是说当我们的数据变更时，vue会帮你更新所有网页中用到它的地方。关于这个响应式原理，官方已经讲得很清楚，[请参考](https://cn.vuejs.org/v2/guide/Reactivity.html)

---

## 2.如何理解Vue是一套渐进式的框架

渐进式是什么意思？

1. 如果你有一个现成的服务端应用，你可以将vue作为该应用的一部分嵌入其中，带来更加丰富的交互体验
2. 如果你希望将更多业务逻辑放到前端来实现，那么vue的核心库及其生态系统也可以满足你的各式需求(core+vuex+vue-router)。和其他前端框架一样，vue允许你将一个网页分割成可复用的组件，每个组件包含属于自己的Html、css。JavaScript用来渲染网页中相应的地方。
3. 如果我们构建一个大型的应用，在这一点上，我们可能需要将东西分割成各自的组件和文件，vue有一个命令行工具，使快速初始化一个真实的工程变得非常简单。我们可以用vue的单文件组件，它包含了各自的Html、Css、JavaScript以及带作用域的Css或者Scss。

以上三个例子，是一步步递进的，也就是说对Vue的使用可大可小，它都会有相应的方式整合到你的项目中。所以说它是一个渐进式的框架。

---

## 3.vue生命周期

**vue生命周期指的是**：vue实例从创建到销毁的过程 -- 开始创建、初始化数据、编译模板、挂载DOM->渲染、更新->渲染、卸载

**生命周期函数**

- `beforCreate`：实例初始化后 ，未有`data`、`event`、`watcher`

- `created`：实例创建完成，已有`data`,属性和方法的运算，watch/event的事件回调。未有`$el`

- `beforMount`：挂载开始前 相关的`render`函数首次被调用

- `mounted`：挂载完成，此时有`$el`

- `beforeUpdate`：数据更新时调用，虚拟DOM打补丁之前

- `updated`：虚拟DOM重新渲染和打补丁后调用

- `beforeDestroy`：实例销毁前

- `destroyed`：实例销毁后

- `activated`：keep-alive组件激活时

- `deactivated`：keep-alive组件停用时

- `errorCaptured(2.5.0+)`：捕获一个来自子孙组件的错误时被调用，此钩子有三个参数：错误对象、发送错误的组件实例、包含错误来源信息的字符串

---

## 4.Vue的两个核心

**1. 数据驱动，也叫双向数据绑定**

`Vue`数据观测原理在实现上，是利用了es5的 `Object.defiedProperty`和存储器属性: `getter`和`setter`(所以只兼容IE 9及以上版本)，主要核心是VM，也就是ViewModel，保证数据和视图的一致性

**2. 组件系统**

- 1、模板(template): 模板声明了数据和最终展现给用户的DOM之间的映射关系。
- 2、初始数据(data): 一个组件的初始数据状态，对于可复用的组件来说，这通常是私有的状态。
- 3、接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享
- 4、方法(methods)：对数据的改动操作一般都在组件的方法内进行
- 5、生命周期钩子函数：一个组件会触发多个生命周期钩子函数
- 6、私有资源(assets)：Vue当中将用户自定义的指令、过滤器、组件等统称为资源。一个组件可以生命自己的私有资源，私有资源只有该组件和他的子组件可以调用

---

## 5.Vue常用指令

`v-if`: 根据条件真假判断是否渲染元素，在切换时元素及他的数据绑定/组件被销毁并重建

`v-show`: 根据条件真假判断，切换元素的css中display的属性 none/block

`v-for`: 循环指令

`v-bind`: 动态绑定一个或多个特性，v-bind:name= ，简写 :name=

`v-on`: 监听执行元素的事件，比如点击事件 v-on:name,简写 @name

`v-model`: 实现表单输入和应用状态之间的双向绑定

`v-pre`: 跳跳过这个元素和它的子元素的编译过程。一些静态的内容不需要编辑加这个指令可以加快编辑

`v-once`: 只渲染元素和组件一次

`v-html`: 更新元素的innerHTML

`v-text`: 更新元素的textContent

---

## 6.v-if和v-show的区别

**共同点**

v-if和v-shoe都是可以动态显示/隐藏DOM元素

**不同点**

1. **编译过程**：v-if是真正的条件渲染，会确保在切换过程中条件模块内的 事件监听器和子组件适当的销毁和重建，而v-show的元素始终会被渲染并保留在DOM中，因为v-show只是简单切换元素css的display属性
2. **编译条件**：v-if是惰性的，如果在初始渲染时条件为假，则什么也不做，直到条件第一次为真时，才开始渲染条件快，而v-show不管初始条件是什么，元素都会被渲染，只是会根据条件设置不同的display属性
3. **性能消耗**：v-if有更高的切换消耗，v-show则有更高的初始渲染消耗
4. **应用场景**：v-if适合条件改变次数少的时候使用，v-show适合频繁切换条件的场景

---

## 7.vue常用修饰符

**v-on常用修饰符**

- `.stop` - 调用event.stopPropagation() 禁止事件冒泡
- `.prevent` - 调用event.preventDefault() 阻止事件默认行为
- `.capture` - 添加事件侦听器时使用capture模式（即内部元素触发的事件先在此处理，然后才交由内部元素进行处理）
- `.self` - 当事件是从侦听器绑定的元素本身触发时才触发回调
- `.{keycde|keyalias}` - 只有当事件是从特定按键触发时才触发的回调 如.enter
- `.native` - 监听组件根元素的原生事件
- `.once` - 只触发一次回调
- `.left` - 只当点击鼠标左键时触发(2.2.0)
- `.right`- 鼠标右键时触发
- `.middle` - 鼠标中键时触发
- `.passive` - 以 `{passive:true}` 模式添加侦听器 (2.3.0)

**v-bind常用修饰符**

- `.prop` - 被用于绑定DOM属性(property)
- `.camel` - 将kebab-case 特性名转为cameCase
- `.sync` - 语法糖，会拓展成一个更新父组件绑定值得v-on侦听器

**v-model常用指令**

- `.lazy` - 取代input监听change事件
- `.number` - 输入字符串转为数字
- `.trim` - 输入首尾空格过滤

---

## 8.v-on可以监听多个方法吗

可以

1. 使用`v-on="{ method1(), method2()}"`的方式，这种方式可以在同一个元素上绑定多个方法。
2. 另一种高级用法是将所有需要传递给子组件的事件函数存储在一个数组中，然后在子组件中使用`v-on="$listener"`的方式来注册这些方法。

---

## 9.vue中key的作用？为什么不推介使用index作为key？

**key 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。**

如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。

使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素

1. key的作用主要是为了高效的更新虚拟DOM（使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素）

2. 当以数组的下标index作为index值时，其中一个元素（如增删改查）发生了变化就有可能导致所有元素的key值发生变化

---

## 10.vue事件中如何使用event对象

vue传递事件对象 `$event` 

有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法

例子：

```vue showLineNumbers copy
<template>
  <a href="javascript:;" data-id="1" @click="clickEvent($event)">event</a>
</template>

<script>
export default {
  methods: {
    clickEvent(event){
      // 获取data-id
      console.log(event.target.dataset.id)
      // 阻止事件冒泡
      event.stopPropagation()
    }
  }
}
</script>
```

## 11.vue中$nextTick的使用

**nextTick的定义**

在DOM更新完后在执行回调函数，简单理解:就是当数据更新完，DOM渲染完毕后，在执行回调函数

**nextTick只需了解这么多**

1. 修改data数据后，数据不是实时更新的。
2. 当你需要在数据更新dom后执行某个操作，该操作需要放在nextTick中。

>当你设置 vm.someData = ‘new value’，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。如果你想基于更新后的 DOM 状态来做点什么，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。

**使用场景**
1. 在生命周期created()中进行的dom操作一定要放到nextTick()的回调函数中。
2. 在数据变化后要执行某个操作，而这个操作需要使用随数据变化而变化的dom结构时，这个操作都应该放进nextTick()的回调函数中。

**原因**

原因是，Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。
当你设置 vm.someData = 'new value'，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。

---

## 12.异步更新队列

Vue在观察到数据变化时并不是直接更新DOM，而是开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。
所以同一个watcher被多次触发，只会添加到队列一次，因此可以去除重复数据可以避免不必要的计算和DOM操作

Vue在内部对异步队列尝试使用原生的Promise.then 、 MutationObserver和setImmediate,
如果以上都不支持，则采用setTimeout(fn,0)代替

---

## 13.data为什么是个函数

JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。而在Vue中，我们更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当我们每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。

这个是因为js本身的特性（原型链）带来的，和vue本身设计无关

---

## 14.v-for和v-if的优先级

**vue2.x 在同一个节点上，v-for的优先级比v-if优先级高**

**vue3.x的优先级则相反，v-if优先级比v-for高**

**注意事项**

永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）

---

## 15.vue组件通信方式

1. 父传子
2. 子传父
3. eventbus
4. ref/$refs
5. $parent/$children
6. $attrs/$listeners
7. 依赖注入(provide/inject)

[参考](/vue/vue2/vue_1)

---

## 16.keep-alive组件

**keep-alive组件的作用**

keep-alive 主要用于保留组件状态和避免重新渲染，常见就是列表页进入详情页，返回列表页时可以从缓存中快速渲染，而不是重新渲染

**keep-alive的属性**

- include: 字符串或正则表达式，只有匹配的组件会被缓存
- exclude: 字符串或正则表达式，任何匹配的组件都不会被缓存

>exclude的优先级大于includes

**keep-alive的生命周期**

- activated: 被 keep-alive 缓存的组件激活时调用。
- deactivated: 被 keep-alive 缓存的组件失活时调用。

>vue性能优化的一种方式

---

## 17.Vue更新数组时触发视图更新的方法

**Vue包含一组观察数组的编译方法，所以他们将会触发视图更新，方法如下：**

- `push()` - 数组添加元素
- `pop()` - 移除最后一个元素
- `shift()` - 删除第一个元素，并返回该元素
- `unshift()` - 在数组开头添加元素，并返回新的长度
- `splice()` - 向数组添加/删除项目，并返回删除的项目
- `sort()` - 数组排序
- `reverse()` - 调到数组元素的顺序

---

## 18.data更新但视图没更新的原因

**vue不能检测以下变动的数组**

1. 利用索引直接设置一个项：`vm.items[index] = value`
2. 修改数组长度时：vm.items.length = newLength

**Vue不能检测对象属性的新增和删除**

因为vue会在初始化实例时对属性执行getter和setter转化，所以属性必须在data对象中存在才能让vue将他转为响应式的

```js showLineNumbers copy
var vm = new Vue()
data = { a: 1}
vm.a = 2 // 这是响应式的
vm.b = 3 // 这不是响应的
```

可以使用Vue.set触发视图更新，如果是数组长度修改，则可以用vm.list.splice(newLength)

---

## 19.Vue等单页面应用的优缺点

 **单页面应用（SPA）**

它是指只有一个主页面的应用，浏览器y一开始加载所有的html ,js 以及css，这些所用页面的内容都包含在这个主页面中，但是在手写中，他们还是分开来书写的，在交互的时候，由路由程序动态载入，单页面的页面跳转，是整页刷新的。

组成：是由一个外壳和多个页面片段组成 

**单页面的优点：**

1. 用户的体验好，快，内容的改变不需要重新加载整个页面，由于这点，SPA它对服务器的压力小
2. 前后端分离
3. 页面效果比较炫酷

**单页面的缺点：**

1. 不利于seo优化
2. 导航不可用
3. 初次加载时耗时多
4. 页面的复杂程度提高了很多

---

## 20.计算属性的缓存和方法调用的有什么区别

- 计算属性必须返回结果
- 计算属性是基于它的依赖缓存的，一个计算属性所依赖的数据发生变化时，它才会重新取值
- 使用计算属性还是methods，取决于是否需要缓存，当遍历大数据和做大量计算时，应当使用计算属性
- 计算属性是根据依赖自动执行的，methods需要事件调用

---

## 21.vue自定义指令

**如何使用自定义指令**

```js showLineNumbers copy
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus',{
  // 当被绑定的元素插入到 DOM 中时……  
  inserted: function (el) { 
    // 聚焦元素 
    el.focus()
  }
})
```

```html showLineNumbers copy
<input v-focus />
```

**自定义指令的钩子函数**

- `bind` - 只调用一次，指令第一次绑定到元素时调用
- `inserted` - 被绑定元素插入父节点时调用
- `update` - 所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前
- `componentUpdated` - 指令所在组件的VNode及其子VNode全部更新后调用
- `unbind` - 只调用一次，指令与元素解绑时调用

---

## 22.computed和watch区别

**1.computed的特点**

(1) 支持缓存，默认走缓存，多次调用，只会执行一次计算。只有依赖的数据发生改变，才会重新计算；

(2) 不支持异步，如果有异步操作，无法监听；

(3) 属性值为函数，默认使用get方法，当数据改变时，会调用set方法；

(4) 主要解决模版中放入过多的逻辑导致不好维护的问题；

**2. watch的特点**

(1) 不支持缓存，只要数据发生变化，就会触发相应的操作；

(2) 支持异步监听；

(3) 接收两个参数，第一个是最新值，第二个是之前的值；

(4) 还有两个其他参数：deep：默认false，深度监听，immediate：默认false，初始化时执行回调函数；

**3.总结**

(1) computed计算属性，他依赖其他属性值，有缓存，只有依赖的值发生变化才会去重新计算，但是不能异步；

(2) watch监听，监听数据的变化，无缓存，数据变化就会执行回调，可以异步；

[计算属性computed和watch监视的使用和区别](/vue/vue2/vue_2)

---

## 23.Object.defineProperty 和 proxy的区别

1. `Object.defineProperty`只能劫持对象的属性，需要遍历对象的每个属性，如果属性值也是对象，则需要深度遍历，而proxy是直接代理对象，不需要遍历操作
2. `Object.defineProperty`对新增属性需要手动进行observe，因为defineproperty劫持的是对象的属性，所以新增属性时，需要重新遍历对象，再对新增属性再使用defineproperty进行劫持。而proxy可以直接监听对象属性的添加

也是因为这个原因，vue2.0在给data中的数组或对象新增属性时，需要用vm.$set来保证新增属性的响应

**简单的说**

definedProperty的缺陷

- 不能监听数组变化
- 必须遍历对象的每个属性
- 必须深层遍历嵌套对象

**proxy对比definedProperty的优点**

- proxy监听的是整个对象而不是对象的某个属性
- proxy可以监听数组的变化
- proxy结果返回一个新的对象，可以直接操作新对象，而不是像definedproperty遍历属性进行修改
- proxy相对性能更好
- proxy对浏览器的兼容性不够

---

## 24.vue diff算法

**diff算法的时间复杂度**

两个树的完全的diff算法是一个时间复杂度为 O(n3)，Vue进行了优化，转为了O(n)(只比较同级不考虑跨级问题)。因为在前端操作DOM的时候，不会把当前元素作为上一级或者下一级元素，很少会跨越层级地移动DOM元素，常见都是同级比较，所以vue只会对同一层级的元素进行比较

**diff算法原理和过程**

在数据发生变化时，Vue是先根据真实DOM生成一颗virtual DOM,当virtual DOM某个节点的数据改变后会生成一个新的VNode，然后新的Vnode和旧的Vnode作对比，发现不一样的地方就直接修改在真实的DOM上，实现更新节点

**流程简述**

1. 先去同级比较，然后再去比较子节点
2. 先去判断一方有子节点一方没有子节点的情况
3. 比较都有子节点的情况
4. 递归比较子节点

---

## 25.vue slot插槽

**基本用法**

在Vue中，插槽被用于在组件中定义可变的部分。组件可以将其内部的内容暴露出去，允许父级组件在使用该组件时传入自定义内容。这种传递的内容可以是任何类型的Vue实例，包括文字、HTML标签、其他组件等。

插槽的基本用法是在子组件中定义`<slot></slot>`元素。这个元素将作为一个占位符，用于接收父级组件传递过来的内容。具名插槽： 具名插槽允许你为组件的不同部分提供不同的内容。在组件模板中，你可以通过`<slot>`元素的name属性来定义具名插槽。例如： 

```vue showLineNumbers copy
// 子组件 ChildComponent.vue
<template>
  <div>
    <h1>子组件</h1>
    <slot></slot>
  </div>
</template>
```

```vue showLineNumbers copy
// 父组件 ParentComponent.vue
<template>
  <div>
    <h1>父组件</h1>
    <ChildComponent>
      <p>这是插槽的内容</p>
    </ChildComponent>
  </div>
</template>
```

在上面的例子中，我们在子组件中定义了一个插槽，然后在父组件中使用`<ChildComponent>`标签，并在标签内部放置了一个`<p>`标签作为插槽的内容。当父组件被渲染时，插槽的内容将被替换为实际传入的内容。

**具名插槽**

在上面的例子中，我们使用的是默认插槽，也就是没有给插槽命名。在某些情况下，我们可能需要定义多个插槽，并且通过名称来区分它们。这就是具名插槽的用法。

具名插槽可以通过在`<slot>`元素上添加`name`属性来定义。下面是一个具名插槽的例子：

```vue showLineNumbers copy
// 子组件 ChildComponent.vue
<template>
  <div>
    <h1>子组件</h1>
    <slot name="header"></slot>
    <slot></slot>
    <slot name="footer"></slot>
  </div>
</template>
```

```vue showLineNumbers copy
// 父组件 ParentComponent.vue
<template>
  <div>
    <h1>父组件</h1>
    <ChildComponent>
      <template v-slot:header>
        <h2>这是头部插槽的内容</h2>
      </template>
      <p>这是默认插槽的内容</p>
      <template v-slot:footer>
        <footer>这是尾部插槽的内容</footer>
      </template>
    </ChildComponent>
  </div>
</template>
```

在上面的例子中，我们在子组件中定义了三个插槽，并分别给它们起了名称。在父组件中，我们使用`v-slot`指令来指定不同的插槽，并在`<template>`中放置插槽的内容。

**作用域插槽**

除了基本的插槽功能，Vue还提供了一种更强大的插槽功能，即作用域插槽。作用域插槽允许子组件向父组件传递数据，实现更为灵活的组件交互。

作用域插槽使用`<slot>`元素中的属性来传递数据。下面是一个作用域插槽的例子：

```vue showLineNumbers copy
// 子组件 ChildComponent.vue
<template>
  <div>
    <h1>子组件</h1>
    <slot v-bind:user="user"></slot>
  </div>
</template>
 
<script>
export default {
  data() {
    return {
      user: {
        name: 'John Doe',
        age: 26
      }
    }
  }
}
</script>
```

```vue showLineNumbers copy
// 父组件 ParentComponent.vue
<template>
  <div>
    <h1>父组件</h1>
    <ChildComponent>
      <template v-slot:default="slotProps">
        <h2>用户信息</h2>
        <p>{{ slotProps.user.name }}</p>
        <p>{{ slotProps.user.age }}</p>
      </template>
    </ChildComponent>
  </div>
</template>
```

在上面的例子中，我们在子组件中定义了一个插槽，并使用`v-bind`指令将`user`对象传递给插槽。在父组件中，我们使用带有`slotProps`名称的属性来接收子组件传递的数据，并在插槽中使用。

**插槽的高级用法**

除了基本和具名插槽以及作用域插槽之外，Vue的插槽还有一些高级用法，如动态插槽、作用域插槽的默认值以及插槽的替代内容。

动态插槽允许在运行时动态选择要使用的插槽。通过使用`v-slot`的值作为动态属性值，可以根据需要选择不同的插槽。下面是一个动态插槽的例子：

```vue showLineNumbers copy
// 子组件 ChildComponent.vue
<template>
  <div>
    <h1>子组件</h1>
    <slot :name="slotName"></slot>
  </div>
</template>
 
<script>
export default {
  data() {
    return {
      slotName: 'header'
    }
  }
}
</script>
```

```vue showLineNumbers copy
// 父组件 ParentComponent.vue
<template>
  <div>
    <h1>父组件</h1>
    <ChildComponent>
      <template v-slot:[slotName]>
        <h2>{{ slotName }}插槽的内容</h2>
      </template>
    </ChildComponent>
    <button @click="changeSlotName">切换插槽</button>
  </div>
</template>
 
<script>
export default {
  data() {
    return {
      slotName: 'header'
    }
  },
  methods: {
    changeSlotName() {
      this.slotName = this.slotName === 'header' ? 'footer' : 'header'
    }
  }
}
</script>
```

在上面的例子中，我们使用了`v-slot`的值作为动态属性值，根据当前的`slotName`选择不同的插槽。点击按钮时，`slotName`的值会发生变化，从而切换到不同的插槽。

**注意事项：**

- 如果未提供任何内容来填充插槽，则插槽内的内容将被视为默认内容，并在组件模板中显示。
- 你也可以使用特殊的语法糖#来定义插槽，例如`<template #header>`等价于`<template v-slot:header>`。

插槽是 Vue.js 的一个非常强大和灵活的特性，它使得组件的结构更加可配置和可复用。通过合理使用插槽，你可以轻松地扩展组件的功能并满足各种不同的使用场景。

---

## 26.vue props如何自定义验证

```js showLineNumbers copy
export default {
  props: {
    num: {
      default: 1,
      validator: function(value) {
        // 返回false则验证不通过，报错 
        return value <= 2;
      }  
    }
  }
}
```

---

## 27.如何让CSS只在当前组件中起作用

Vue可以通过使用scoped属性来限制样式仅应用于特定的组件。

在单文件组件（.vue）中，将style标签添加scoped属性，示例如下所示：

```vue showLineNumbers copy
<template>
  <!-- 模板内容 -->
</template>
 
<script>
export default {
  // 组件逻辑
}
</script>
 
<style scoped>
/* CSS样式 */
</style>
```

这样设置后，该组件的CSS样式就会被局部化，不会影响其他组件或全局样式。

---

## 28.相同路由组件如何重新渲染

Vue默认不会对相同的路由的切换做重新渲染

如果需要重新渲染，可以添加key

```vue showLineNumbers copy
<template>
  <router-view :key="$route.path"></router-view>
</tempalte>
```

---

## 29.如何获取data某个数值的初始值

data的属性改变后，可以通过`this.$options.data().x` 获取初始值

---

## 30.created和mounted的区别

created和mounted都是Vue生命周期钩子函数，但它们的执行时机不同。

created是在实例创建完成后立即执行的钩子函数，此时组件的DOM节点还未生成，数据也还未渲染到页面上。

mounted是在组件挂载到页面上后执行的钩子函数，此时组件的DOM节点已经生成，数据也已经渲染到页面上。

因此，如果需要在组件创建时进行一些数据初始化的操作，可以使用created钩子函数；如果需要在组件挂载到页面上后进行一些DOM操作或与后端交互的操作，可以使用mounted钩子函数。

---

## 31.v-model语法糖是怎么实现的

`v-model`是`value` + `input`的语法糖，是`v-band`和`v-on`的简洁写法。`v-model`就实现了双向数据绑定，实际上它就是通过Vue提供的事件机制。即在子组件通过`$emit()`触发一个事件，在父组件使用`v-model`即可

---

## 32.vue eventbus(事件总线)具体是怎么实现的

`EventBus` 又称为事件总线。在Vue中可以使用 `EventBus` 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎，就会造成难以维护的"灾难"，因此才需要更完善的`Vuex`作为状态管理中心，将通知的概念上升到共享状态层次。

[Vue事件总线(EventBus)使用详细介绍](/vue/vue2/vue_3)

---

## 33.说说vue操作真实dom性能瓶颈

1. **DOM 操作的代价** ：直接操作 DOM 是昂贵的操作，因为它涉及到浏览器渲染引擎的重新计算、布局和绘制。Vue 通过虚拟 DOM 尽量减少了对真实 DOM 的操作，但在某些情况下，如使用 ref 或 $el 直接访问 DOM 元素时，我们可能会不自觉地触发大量的 DOM 操作，从而影响性能。
2. **异步更新队列** ：Vue 在更新 DOM 时，会先将需要更新的节点放入一个异步队列中，等到下一个事件循环再执行实际的 DOM 更新。这意味着，如果你在 Vue 的更新过程中直接操作了真实 DOM，可能会覆盖 Vue 的更新，导致视图不一致。
3. **破坏响应式系统** ：Vue 的响应式系统依赖于数据的观察者。当你直接修改一个响应式对象时，Vue 可能无法检测到这种变化，从而导致视图不更新。这可能会让你觉得操作真实 DOM 是一种解决方法，但实际上，这样做可能会破坏 Vue 的响应式系统，使你的应用状态变得难以预测。
4. **难以维护** ：过度依赖直接操作 DOM 会使你的代码难以理解和维护。当 DOM 结构或样式发生变化时，这些直接操作 DOM 的代码可能会变得无效或引发错误。

为了避免这些问题，你可以考虑以下建议：

- **尽量使用 Vue 的指令和 API**：Vue 提供了许多用于操作 DOM 的指令和 API，如 v-if、v-for、v-show、v-model 等。这些指令和 API 在设计时已经考虑到了性能因素，可以确保视图和数据的同步。
- **使用计算属性和侦听器** ：当需要基于现有数据计算新值时，可以使用计算属性。当依赖的数据发生变化时，计算属性会自动重新计算。同样，侦听器可以用来观察数据的变化，并在数据变化时执行特定的函数。
- **避免在循环或频繁触发的事件处理程序中直接操作 DOM** ：在循环中直接操作 DOM 会导致性能问题，因为每次迭代都会触发 DOM 操作。同样，在频繁触发的事件处理程序中直接操作 DOM 也会导致性能问题。在这些情况下，考虑使用虚拟 DOM 或其他优化技术。
- **使用 Vue 的过渡和动画 API** ：Vue 提供了过渡和动画 API，可以帮助你以性能友好的方式实现动画效果。这些 API 利用了 CSS3 的过渡和动画特性，而不是直接操作 DOM。

---

## 34.Vue中如何获取dom、操作dom、更新dom

在Vue中，可以通过ref属性来获取DOM元素。首先需要为目标DOM元素添加ref属性，然后使用this.$refs.xxx来访问该DOM元素。

示例代码如下所示：

```vue showLineNumbers copy
<template>
  <div ref="myDiv">Hello Vue!</div>
</template>
 
<script>
export default {
  mounted() {
    // 获取DOM元素
    const myElement = this.$refs.myDiv;
    
    // 对DOM进行操作
    myElement.style.color = 'red';
  
    // 更新DOM内容
    myElement.innerText = 'Updated DOM content';
  }
}
</script>
```

---

## 35.vue中为什么用虚拟dom而不操作真实dom

不直接操作真实DOM，因为很昂贵，我们去操作这个JS对象，就不会触发大量回流重绘操作，再加上diff算法，可以找到两次虚拟DOM之间改变的部分，从而最小量的去一次性更新真实DOM，而不是频繁操作DOM，性能得到了大大的提升。

---

## 36.说说vue中的虚拟dom和diff算法

在Vue（以及许多其他前端框架和库，如React）中，虚拟DOM（Virtual DOM）和diff算法是两个核心概念，它们共同提高了应用程序的性能和响应速度。

**虚拟DOM（Virtual DOM）**

虚拟DOM是一个编程概念，其中一个“虚拟的”节点树被用作中间层，将真实DOM树与底层数据保持同步。每当数据发生变化时，Vue会创建一个新的虚拟节点树，并将其与旧的虚拟节点树进行比较，而不是直接修改真实的DOM树。这种方式的优点在于，操作虚拟DOM（在内存中进行）比在DOM上执行DOM操作要快得多，因为DOM操作通常涉及到昂贵的重排和重绘。

**Diff算法**

Diff算法（也称为Reconciliation或Reconciliation Algorithm）是Vue（以及React）用来比较两棵虚拟DOM树并确定如何有效地将一棵树转换为另一棵树的算法。这个算法的核心思想是比较两棵树中的节点，并确定最小的改变集，以便应用这些改变到实际的DOM上。

Vue的Diff算法有以下关键特点：

1. **深度优先遍历** ：Vue会深度优先遍历两棵树，对树中的每个节点进行比较。
2. **Key值** ：Vue使用每个节点的key属性来确定节点是否改变、被添加或被删除。如果没有提供key值，Vue会使用一个基于索引的key，这可能在列表操作中导致性能问题。
3. **节点比较** ：如果两个节点是同一类型（即，它们都是元素节点或都是组件节点），Vue会进一步比较它们的属性和子节点。
4. **最小化DOM操作** ：Vue会尝试最小化必要的DOM操作。例如，如果两个节点具有相同的属性和子节点，Vue会重用现有的DOM节点，而不是创建一个新的。

---

## 37.动态给vue的data添加一个新的属性时会发生什么？怎样解决？

动态给vue的data添加一个新的属性时，这个新属性不会被响应式的监听和更新。也就是说，当你修改这个属性时，视图不会发生变化。

解决方法有两种：

**1.使用Vue.set()或this.$set()方法**

可以使用Vue.set(obj, key, value)或this.$set(obj, key, value)方法来向响应式对象中添加一个属性，这样添加的属性就会被监听和更新，可以触发视图的重新渲染。

```js showLineNumbers copy
Vue.set(this.$data, 'newAttribute', 'new value');
// 或者
this.$set(this.$data, 'newAttribute', 'new value');
```

**2.在data中声明属性，并赋予初始值**

另外一种方法是在data中声明所有可能要用到的属性，即使初值为null或undefined。这样，在后续操作中只需要修改这个属性的值即可，因为它已经被监测到了。

```js showLineNumbers copy
export default {
  data: {
    message: 'Hello Vue!',
    newAttribute: null
  },
  methods: {
    updateNewAttribute () {
      this.newAttribute = 'new value';
    }
  }
}
```

---

## 38.vue的mixin的理解，有什么应用场景?

**mixin是什么**

Mixin是面向对象程序设计语言中的类，提供了方法的实现。其他类可以访问mixin类的方法而不必成为其子类

Mixin类通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用又避免了多继承的复杂

**Vue中的mixin**

官方定义

>mixin（混入），提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。

本质其实就是一个js对象，它可以包含我们组件中任意功能选项，如data、components、methods、created、computed等等

我们只要将共用的功能以对象的方式传入 mixins选项中，当组件使用 mixins对象时所有mixins对象的选项都将被混入该组件本身的选项中来

在Vue中我们可以**局部混入**跟**全局混入**

**局部混入**

定义一个mixin对象，有组件options的data、methods属性

```js showLineNumbers copy
var myMixin = {
  created: function () {
    this.hello()
  },
  methods: {
    hello: function () {
      console.log('hello from mixin!')
    }
  }
}
```

组件通过mixins属性调用mixin对象

```js showLineNumbers copy
Vue.component('componentA',{
  mixins: [myMixin]
})
```

该组件在使用的时候，混合了mixin里面的方法，在自动执行create生命钩子，执行hello方法

**全局混入**

通过Vue.mixin()进行全局的混入

```js
Vue.mixin({
  created: function () {
    console.log("全局混入")
  }
})
```

使用全局混入需要特别注意，因为它会影响到每一个组件实例（包括第三方组件）

>PS：全局混入常用于插件的编写

**注意事项：**

当组件存在与mixin对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖mixin的选项

但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行mixin的钩子，再执行组件的钩子

**使用场景**

在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立

这时，可以通过Vue的mixin功能将相同或者相似的代码提出来

举个例子

定义一个modal弹窗组件，内部通过isShowing来控制显示

```js showLineNumbers copy
const Modal = {
  template: '#modal',
  data() {
    return {
      isShowing: false
    }
  },
  methods: {
    toggleShow() {
      this.isShowing = !this.isShowing;
    }
  }
}
```

定义一个tooltip提示框，内部通过isShowing来控制显示

```js showLineNumbers copy
const Tooltip = {
  template: '#tooltip',
  data() {
    return {
      isShowing: false
    }
  },
  methods: {
    toggleShow() {
      this.isShowing = !this.isShowing;
    }
  }
}
```

通过观察上面两个组件，发现两者的逻辑是相同，代码控制显示也是相同的，这时候mixin就派上用场了

首先抽出共同代码，编写一个mixin

```js showLineNumbers copy
const toggle = {
  data() {
    return {
      isShowing: false
    }
  },
  methods: {
    toggleShow() {
      this.isShowing = !this.isShowing;
    }
  }
}
```

两个组件在使用上，只需要引入mixin

```js showLineNumbers copy
const Modal = {
  template: '#modal',
  mixins: [toggle]
};
 
const Tooltip = {
  template: '#tooltip',
  mixins: [toggle]
}
```

通过上面小小的例子，让我们知道了Mixin对于封装一些可复用的功能如此有趣、方便、实用

[参考](https://blog.csdn.net/weixin_44475093/article/details/111189453)

---

## 39.Vue中的过滤器了解吗?过滤器的应用场景有哪些?

**过滤器是什么**

过滤器（filter）是输送介质管道上不可缺少的一种装置

大白话，就是把一些不必要的东西过滤掉

过滤器实质不改变原始数据，只是对数据进行加工处理后返回过滤后的数据再进行调用处理，我们也可以理解其为一个纯函数

Vue 允许你自定义过滤器，可被用于一些常见的文本格式化

>ps: Vue3中已废弃filter

**如何用**

vue中的过滤器可以用在两个地方：双花括号插值和 v-bind 表达式，过滤器应该被添加在 JavaScript表达式的尾部，由“管道”符号指示：

```html showLineNumbers copy
<!-- 在双花括号中 -->
{{ message | capitalize }}

<!-- 在 `v-bind` 中 -->
<div v-bind:id="rawId | formatId"></div>
```

**定义filter**

在组件的选项中定义本地的过滤器

```js showLineNumbers copy
export default {
  filters: {
    capitalize: function (value) {
      if (!value) return ''
      value = value.toString()
      return value.charAt(0).toUpperCase() + value.slice(1)
    }
  }
}
```

定义全局过滤器：

```js showLineNumbers copy
Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})
​
new Vue({
  // ...
})
```

>注意：当全局过滤器和局部过滤器重名时，会采用局部过滤器

过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，capitalize 过滤器函数将会收到 message 的值作为第一个参数

过滤器可以串联：

``` showLineNumbers copy
{{ message | filterA | filterB }}
```

在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。

过滤器是 JavaScript函数，因此可以接收参数：

```js showLineNumbers copy
{{ message | filterA('arg1', arg2) }}
```

这里，filterA 被定义为接收三个参数的过滤器函数。

其中 message 的值作为第一个参数，普通字符串 'arg1' 作为第二个参数，表达式 arg2 的值作为第三个参数

举个例子：

```vue showLineNumbers copy
<div id="app">
  <p>{{ msg | msgFormat('疯狂','--')}}</p>
</div>

<script>
  // 定义一个 Vue 全局的过滤器，名字叫做  msgFormat
  Vue.filter('msgFormat', function(msg, arg, arg2) {
    // 字符串的  replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则
    return msg.replace(/单纯/g, arg+arg2)
  })
</script>
```

**小结：**

- 部过滤器优先于全局过滤器被调用
- 一个表达式可以使用多个过滤器。过滤器之间需要用管道符“|”隔开。其执行顺序从左往右

**应用场景**

平时开发中，需要用到过滤器的地方有很多，比如单位转换、数字打点、文本格式化、时间格式化之类的等

比如我们要实现将30000 => 30,000，这时候我们就需要使用过滤器

```js showLineNumbers copy
Vue.filter('toThousandFilter', function (value) {
  if (!value) return ''
  value = value.toString()
  return .replace(str.indexOf('.') > -1 ? /(\d)(?=(\d{3})+\.)/g : /(\d)(?=(?:\d{3})+$)/g, '$1,')
})
```

---

## 40.是怎么处理vue项目中的错误的?

[参考](https://blog.csdn.net/KlausLily/article/details/124185829)

---

## 41.vue要做权限管理该怎么做?

**路由层面控制**

在路由层面进行控制，可以在路由的元数据 meta 中设置用户权限，然后可以在路由守卫函数中进行校验。如果当前用户的权限符合该路由的要求，则策略继续进行，否则将导航到其他页面。

```js showLineNumbers copy
const routes = [
  {
    path: '/home',
    name: 'home',
    component: Home,
    meta: {
      requireAuth: true, // 需要用户权限
      roles: ['admin', 'guest'] // 受访问限制的角色
    }
  },
  {
    path: '/login',
    name: 'login',
    component: Login
  }
]

// 创建路由实例
const router = new VueRouter({
  routes
});

// 添加路由前置守卫
router.beforeEach((to, from, next) => {
  // 判断该路由是否需要登录权限
  if (to.meta.requireAuth) {
    // 如果需要，则校验用户是否已经登录
    if (Vue.auth.loggedIn()) {
      // 判断当前用户是否有访问该路由的权限
      if (to.meta.roles.indexOf(Vue.auth.getUserRole()) !== -1) {
        // 用户有访问权限，直接进入页面
        next()
      } else {
        // 跳转其他页面
        next('/denied')
      }
    } else {
      // 如果用户未登录，则跳转登录页面
      next('/login')
    }
  } else {
    // 如果不需要登录权限，直接进入页面
    next()
  }
});
```

在上面的代码中，路由的元数据 meta 中设置了 requireAuth 和 roles 两个属性，requireAuth 表示该路由需要用户登录才能访问，roles 表示受访问限制的角色。可以在 beforeEach 路由守卫函数中校验用户权限，如果用户有访问该路由的权限，则进入页面，否则跳转到其他页面。这样，就可以在路由层面进行权限控制了。

**组件层面控制**

在组件层面进行控制，可以利用 Vue 的指令来控制组件的显示和隐藏。例如，可以为每个组件设置一个权限属性，然后在指令中判断当前用户是否有访问该组件的权限，如果有，则显示组件，否则隐藏组件。

下面是一个组件示例：

```vue showLineNumbers copy
<template>
  <div v-if="allow">
    This is a component that requires authentication
  </div>
  <div v-else>
    You are not authorized to view this component
  </div>
</tempalte>
<script>
export default {
  data() {
    return {
      allow: false
    }
  },
  mounted() {
    // 获取当前用户权限，并根据权限设置组件的显示和隐藏
    if (Vue.auth.getCurrentUserRole()) === 'admin' {
      this.allow = true
    }
  }
}
</script>
```

在上面的代码中，利用 v-if 指令来判断当前用户是否有访问该组件的权限，并根据权限设置组件的显示和隐藏。这样，就可以在组件层面进行权限控制了。

---

## 42.vue项目本地开发完成后部署到服务器后报404是什么原因呢?

**1. 路径问题**

在开发Vue项目时，我们通常使用相对路径引用资源文件（如CSS、JS、图片等），但是在将项目部署到服务器时，相对路径可能会发生变化，导致无法找到相应的资源。此时可以通过使用绝对路径来解决这个问题，或者确保部署路径与相对路径一致。

**2. 服务器配置问题**

有时候，404错误也可能是由于服务器配置问题导致的。比如，服务器没有安装相关的依赖项或者配置不正确等。如果出现这种情况，需要检查服务器的配置是否正确，并进行相应的修复。

**3. 编译问题**

在开发Vue项目时，我们通常使用Webpack等工具对代码进行编译和打包。如果编译出现问题，可能会导致部署后的项目无法正常访问。此时可以检查编译是否成功以及是否存在语法错误等。

**4. 访问权限问题**

如果部署的服务器存在访问权限限制，可能会导致某些资源无法正常访问。此时可以检查访问权限设置是否正确，并根据需要进行相应的修改。

---

## 43.在Vue中，子组件为何不可以修改父组件传递的Prop

Vue提倡单向数据流,即父级props的更新会流向子组件,但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。

---

## 44.双向绑定和vuex是否冲突

双向绑定和Vuex并不直接冲突，但在某些情况下可能会引起一些问题。

双向绑定是指视图（View）和模型（Model）之间的双向数据绑定，当视图中的数据发生变化时，模型会随之更新；反过来，当模型中的数据发生变化时，视图也会相应地更新。在Vue中，通过`v-model`指令可以实现双向数据绑定。

Vuex是Vue的状态管理库，用于集中管理应用程序的状态。它提供了一个单一的、可预测的状态树，并通过mutation和action来修改和管理状态。Vuex的核心思想是通过单向数据流来管理状态，即从状态树到视图的单向数据流。

在使用Vuex时，可以将状态存储在Vuex的状态树中，并通过getter获取状态，通过mutation来修改状态。这种方式可以保持状态的一致性和可追踪性，避免了多个组件直接修改共享状态的问题。

然而，当双向绑定和Vuex同时使用时，可能会引起一些问题。双向绑定可能导致视图直接修改了Vuex中的状态，而绕过了Vuex的mutation，这可能破坏了状态的可预测性和一致性。另外，在大型应用中，双向绑定可能导致状态的变更难以追踪和调试。

为了避免这些问题，通常建议在使用Vuex时尽量避免直接在组件中使用双向绑定。相反，通过使用Vuex的getter来获取状态，在组件中使用单向数据流来更新视图。如果需要在组件中修改状态，应该使用Vuex的mutation或action来进行，以保持状态管理的一致性和可追踪性。

---

## 45.Vue的父组件和子组件生命周期钩子执行顺序是什么

**加载渲染过程**

父beforeCreate --> 父created --> 父beforeMount --> 子beforeCreate --> 子created --> 子beforeMount --> 子Mounted --> 父Mounted

**子组件更新过程**

父beforeUpdate --> 子beforeUpdate --> 子updated --> 父updated

**父组件更新过程**

父beforeUpdate --> 父updated

**销毁过程**

父beforeDestory --> 子beforeDestory --> 子destoryed --> 父destoryed

---

## 46.vue在v-for时给每项元素绑定事件需要用事件代理吗?为什么?

Vue 并没有在源码中做代理

但是一般给 v-for 绑定事件时，都会让节点指向同一个事件处理程序（第二种情况可以运行，但是 eslint 会警告），一定程度上比每生成一个节点都绑定一个不同的事件处理程序性能好，但是监听器的数量仍不会变，所以使用事件代理会更好一点。

