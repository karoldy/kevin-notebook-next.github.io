# Vue2 面试题

## 1.MVVM框架的理解

**MVVM**是**Model-View-ViewModel**的简写。即【模型】-【视图】-【视图模型】

- 【模型】(Model): 指的是后端传递的数据
- 【视图】(View): 指的是所看到的页面
- 【视图模型】(ViewModel): mvvm模式的核心, 它是连接view和model的桥梁。

**视图模型有两个方向: **

一是将【模型】转化成【视图】, 即将后端传递的数据转化成所看到的页面。实现的方式是数据绑定。

二是将【视图】转化成【模型】, 即将所看到的页面转化成后端的数据。实现的方式是: DOM事件监听。

这两个方向都实现的, 我们称之为数据的双向绑定。

**总结: **

在MVVM的框架下视图和模型是不能直接通信的。它们通过viewModel来通信, ViewModel通常要实现一个observer观察者, 当数据发生变化, ViewModel能够监听到数据的这种变化, 然后通知到对应的视图做自动更新, 而用户操作视图, ViewModel也能监听到视图的变化, 然后通知数据做改动, 这实际上就实现了数据的双向绑定。并且MVVM中的view和ViewModel可以互相通信。

>Vue就是基于MVVM实现的一套框架, 在vue中, 【模型】指的是JavaScript中的数据, 如对象, 数组等。【视图】指的是页面视图。【视图模型】指的是vue的实例化对象。

>Vue最独特的特性: 响应式系统。vue是响应式的, 也就是说当我们的数据变更时, vue会帮你更新所有网页中用到它的地方。关于这个响应式原理, 官方已经讲得很清楚, [请参考](https://cn.vuejs.org/v2/guide/Reactivity.html)

---

## 2.如何理解Vue是一套渐进式的框架

渐进式是什么意思?

1. 如果你有一个现成的服务端应用, 你可以将vue作为该应用的一部分嵌入其中, 带来更加丰富的交互体验
2. 如果你希望将更多业务逻辑放到前端来实现, 那么vue的核心库及其生态系统也可以满足你的各式需求(core+vuex+vue-router)。和其他前端框架一样, vue允许你将一个网页分割成可复用的组件, 每个组件包含属于自己的Html、css。JavaScript用来渲染网页中相应的地方。
3. 如果我们构建一个大型的应用, 在这一点上, 我们可能需要将东西分割成各自的组件和文件, vue有一个命令行工具, 使快速初始化一个真实的工程变得非常简单。我们可以用vue的单文件组件, 它包含了各自的Html、Css、JavaScript以及带作用域的Css或者Scss。

以上三个例子, 是一步步递进的, 也就是说对Vue的使用可大可小, 它都会有相应的方式整合到你的项目中。所以说它是一个渐进式的框架。

---

## 3.请描述下对vue生命周期的理解

**vue生命周期指的是**: vue实例从创建到销毁的过程 -- 开始创建、初始化数据、编译模板、挂载DOM->渲染、更新->渲染、卸载。而vue在这一系列过程中提供了生命周期函数。

**生命周期函数**

- `beforCreate`: 实例初始化后 , 未有`data`、`event`、`watcher`

- `created`: 实例创建完成, 已有`data`,属性和方法的运算, watch/event的事件回调。未有`$el`

- `beforMount`: 挂载开始前 相关的`render`函数首次被调用

- `mounted`: 挂载完成, 此时有`$el`

- `beforeUpdate`: 数据更新时调用, 虚拟DOM打补丁之前

- `updated`: 虚拟DOM重新渲染和打补丁后调用

- `beforeDestroy`: 实例销毁前

- `destroyed`: 实例销毁后

- `activated`: keep-alive组件激活时

- `deactivated`: keep-alive组件停用时

- `errorCaptured(2.5.0+)`: 捕获一个来自子孙组件的错误时被调用, 此钩子有三个参数: 错误对象、发送错误的组件实例、包含错误来源信息的字符串

---

## 4.vue双向数据绑定是什么

Vue 内部通过 `Object.defineProperty`方法属性拦截的方式, 把 `data` 对象里每个数据的读写转化成 `getter/setter`, 当数据变化时通知视图更新。

[Vue双向数据绑定原理详解](/vue/docs1/docs_2)

---

## 5.vue组件之间的通信方式都有哪些?

1. 父传子
2. 子传父
3. eventbus
4. ref/$refs
5. $parent/$children
6. $attrs/$listeners
7. 依赖注入(provide/inject)

[参考](/vue/vue2/vue_1)

---

## 6.为什么data属性是一个函数而不是一个对象?

JavaScript中的对象是引用类型的数据, 当多个实例引用同一个对象时, 只要一个实例对这个对象进行操作, 其他实例中的数据也会发生变化。而在Vue中, 我们更多的是想要复用组件, 那就需要每个组件都有自己的数据, 这样组件之间才不会相互干扰。所以组件的数据不能写成对象的形式, 而是要写成函数的形式。数据以函数返回值的形式定义, 这样当我们每次复用组件的时候, 就会返回一个新的data, 也就是说每个组件都有自己的私有数据空间, 它们各自维护自己的数据, 不会干扰其他组件的正常运行。

这个是因为JavaScript本身的特性(原型链)带来的, 和vue本身设计无关

---

## 7.动态给vue的data添加一个新的属性时会发生什么?怎样解决?

新属性数据改变了, 视图不会更新

原因是: Vue创建实例时, 并没有声明这个属性, 所以没有被转Vue换成响应式属性, 自然就不会触发视图的更新

解决方法:

- 如果为对象添加少量的新属性, 可以直接采用`Vue.set()`
- 如果需要为新对象添加大量的新属性, 则通过`Object.assign()`创建新对象
- 如果你实在不知道怎么操作时, 可采取`$forceUpdate()`进行强制刷新 (不建议)

> vue3是用过proxy实现数据响应式的, 直接动态添加新属性仍可以实现数据响应式

---

## 8.v—if和v—for的优先级是什么?

在vue2中, `v-for`优先级比`v-if`高

在vue3中, `v-if`优先级比`v-for`高

**注意事项**

1. v-if和v-for不能同时使用
2. 同时使用需要在外层嵌套盒子, 在外层进行v-if判断, 在内层进行v-for循环

---

## 9.v-show和v—if有什么区别?使用场景分别是什么?

`vue` 中` v-show` 与 `v-if` 的作用效果是相同的(不含`v-else`), 都能控制元素在页面是否显示

**区别**

- 控制手段不同

v-show隐藏则是为该元素添加`css--display:none`, dom元素依旧还在。`v-if`显示隐藏是将`dom`元素整个添加或删除

- 编译过程不同

`v-if`切换有一个局部编译/卸载的过程, 切换过程中合适地销毁和重建内部的事件监听和子组件; `v-show`只是简单的基于css切换

- 编译条件不同

`v-if`是真正的条件渲染, 它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时, 并不做操作, 直到为真才渲染

- 性能消耗

`v-if`有更高的切换消耗; `v-show`有更高的初始渲染消耗;

**使用场景**

- 如果需要非常频繁地切换, 则使用`v-show`较好
- 如果在运行时条件很少改变, 则使用`v-if`较好

---

## 10.你知道vue中key的原理吗?说说你对它的理解

key是给每一个vnode的唯一id, 也是diff的一种优化策略, 可以根据key, 更准确, 更快的找到对应的vnode节点

---

## 11.说说你对vue的mixin的理解, 有什么应用场景?

混入 (mixin) 提供了一种非常灵活的方式, 来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时, 所有混入对象的选项将被“混合”进入该组件本身的选项。

分为

- 局部混入
- 全局混入

>注: 全局混入需要慎用, 因为它连第三方组件都能影响

**应用场景**

针对一些基本功能一样, 但又存在足够差异性的组件之间, 有两种解决方案: 

(1) 一种是拆分成公共组件, 但是这种方式一旦功能变动就要在引入的文件中更新代码, 这违背了DRY原则, 反之, 太多的props传值会很快变得混乱, 导致项目维护难度增加。
(2) 另一种是使用Mixin, Vue 中的Mixin对编写函数式风格的代码很有用, 因为函数式编程就是通过减少移动的部分让代码更好理解。Mixin允许你封装一块在应用的其他组件中都可以使用的函数。如果使用姿势得当, 他们不会改变函数作用域外部的任何东西, 因此哪怕执行多次, 只要是同样的输入你总是能得到一样的值, 真的很强大!

---

## 12.Vue常用的修饰符有哪些有什么应用场景

- `.stop`: 阻止事件冒泡
- `.native`: 绑定原生事件
- `.once`: 事件只执行一次
- `.self`: 将事件绑定在自身身上, 相当于阻止事件冒泡
- `.prevent`: 阻止默认事件
- `.caption`: 用于事件捕获
- `.once`: 只触发一次
- `.keyCode`: 监听特定键盘按下
- `.right`: 右键

---

## 13.Vue中的$nextTick有什么作用?

官方对其的定义

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法, 获取更新后的 DOM

什么意思呢?

我们可以理解成, Vue 在更新 DOM 时是异步执行的。当数据发生变化, Vue将开启一个异步更新队列, 视图需要等队列中所有数据变化完成之后, 再统一进行更新

如果想要在修改数据后立刻得到更新后的DOM结构,可以使用`Vue.nextTick()`

---

## 14.Vue实例挂载的过程

- `new Vue`的时候调用会调用`_init`方法
  - 定义 `$set`、`$get`、`$delete`、`$watch` 等方法
  - 定义 `$on`、`$off`、`$emit`、`$off`等事件
  - 定义 `_update`、`$forceUpdate`、`$destroy`生命周期
- 调用`$mount`进行页面的挂载
- 挂载的时候主要是通过`mountComponent`方法
- 定义`updateComponent`更新函数
- 执行`render`生成虚拟DOM
- `_update`将虚拟DOM生成真实DOM结构, 并且渲染到页面中

---

## 15.你了解vue的diff算法吗?

diff 算法是一种通过同层的树节点进行比较的高效算法

其有两个特点: 

- 比较只会在同层级进行, 不会跨层级比较
- 在diff比较的过程中, 循环从两边向中间比较

diff 算法在很多场景下都有应用, 在 vue 中, 作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较

[vue diff算法原理分析](/vue/vue2/vue_4)

---

## 16.Vue中组件和插件有什么区别?

**组件**

组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念(组件)来实现开发的模式, 在Vue中每一个`.vue`文件都可以视为一个组件

**插件**

插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种: 

- 添加全局方法或者属性。如: vue-custom-element
- 添加全局资源: 指令/过滤器/过渡等。如 vue-touch
- 通过全局混入来添加一些组件选项。如vue-router
- 添加 Vue 实例方法, 通过把它们添加到 Vue.prototype 上实现。
- 一个库, 提供自己的 API, 同时提供上面提到的一个或多个功能。如vue-router

**两者的区别主要表现在以下几个方面**:

- 编写形式
- 注册形式
- 使用场景

---

## 17.Vue项目中你是如何解决跨域的呢?

跨域本质是浏览器基于同源策略的一种安全手段

同源策略(Sameoriginpolicy), 是一种约定, 它是浏览器最核心也最基本的安全功能

所谓同源(即指在同一个域)具有以下三个相同点

- 协议相同(protocol)
- 主机相同(host)
- 端口相同(port)

反之非同源请求, 也就是协议、端口、主机其中一项不相同的时候, 这时候就会产生跨域

>一定要注意跨域是浏览器的限制, 你用抓包工具抓取接口数据, 是可以看到接口已经把数据返回回来了, 只是浏览器的限制, 你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。

解决跨域的方法有很多, 下面列举了三种: 

- JSONP
- CORS
- Proxy

**在vue中主要使用Proxy**

代理(Proxy)也称网络代理, 是一种特殊的网络服务, 允许一个(一般为客户端)通过这个服务与另一个网络终端(一般为服务器)进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全, 防止攻击

在`vue.config.js`文件, 新增以下代码

```js showLineNumbers copy
module.exports = {
  devServer: {
    host: '127.0.0.1',
    port: 8084,
    open: true,// vue项目启动时自动打开浏览器
    proxy: {
      '/api': { // '/api'是代理标识, 用于告诉node, url前面是/api的就是使用代理的
        target: "http://xxx.xxx.xx.xx:8080", //目标地址, 一般是指后台服务器地址
        changeOrigin: true, //是否跨域
        pathRewrite: { // pathRewrite 的作用是把实际Request Url中的'/api'用""代替
          '^/api': "" 
        }
      }
    }
  }
}
```

---

## 18.有写过自定义指令吗?自定义指令的应用场景有哪些?

注册一个自定义指令有全局注册与局部注册

全局注册主要是通过`Vue.directive`方法进行注册

`Vue.directive`第一个参数是指令的名字(不需要写上v-前缀), 第二个参数可以是对象数据, 也可以是一个指令函数

```js showLineNumbers copy
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()  // 页面加载完成之后自动让输入框获取到焦点的小功能
  }
})
```

局部注册通过在组件`options`选项中设置`directive`属性

```js showLineNumbers copy
export default {
  directives: {
    focus: {
      // 指令的定义
      inserted: function (el) {
        el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能
      }
    }
  }
}
```

然后你可以在模板中任何元素上使用新的 v-focus property, 如下: 

```html
<input v-focus />
```

**应用场景**

使用自定义指令可以满足我们日常一些场景, 这里给出几个自定义指令的案例: 

- 表单防止重复提交
- 图片懒加载
- 一键 Copy的功能

[vue自定义指令]()

---

## 19.Vue中的过滤器了解吗?过滤器的应用场景有哪些?

过滤器(filter)是输送介质管道上不可缺少的一种装置

大白话, 就是把一些不必要的东西过滤掉

过滤器实质不改变原始数据, 只是对数据进行加工处理后返回过滤后的数据再进行调用处理, 我们也可以理解其为一个纯函数

Vue 允许你自定义过滤器, 可被用于一些常见的文本格式化

>ps: Vue3中已废弃filter

**vue过滤器分为**

- 全局过滤器

```js showLineNumbers copy
Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})

new Vue({
  // ...
})
```

- 局部过滤器

在组件的选项中定义本地的过滤器

```js showLineNumbers copy
export default {
  filters: {
    capitalize: function (value) {
      if (!value) return ''
      value = value.toString()
      return value.charAt(0).toUpperCase() + value.slice(1)
    }
  }
}
```

**使用方式都是**

vue中的过滤器可以用在两个地方: 双花括号插值和 v-bind 表达式, 过滤器应该被添加在 JavaScript表达式的尾部, 由“管道”符号指示:

```html showLineNumbers copy
<!-- 在双花括号中 -->
{{ message | capitalize }}

<!-- 在 `v-bind` 中 -->
<div v-bind:id="rawId | formatId"></div>
```

**应用场景**

平时开发中, 需要用到过滤器的地方有很多, 比如单位转换、数字打点、文本格式化、时间格式化之类的等

比如我们要实现将30000 => 30,000, 这时候我们就需要使用过滤器

```js showLineNumbers copy
Vue.filter('toThousandFilter', function (value) {
  if (!value) return ''
  value = value.toString()
  return .replace(str.indexOf('.') > -1 ? /(\d)(?=(\d{3})+\.)/g : /(\d)(?=(?:\d{3})+$)/g, '$1,')
})
```

---

## 20.说说你对slot的理解?slot使用场景有哪些?

在vue中, 理解为solt在组件模板中占好了位置, 当使用该组件标签时候, 组件标签里面的内容就会自动填坑(替换组件模板中slot位置), 作为承载分发内容的出口

**slot可以分来以下三种**:

- 默认插槽
- 具名插槽
- 作用域插槽

**使用场景**

通过插槽可以让用户可以拓展组件, 去更好地复用组件和对其做定制化处理

如果父组件在使用到一个复用组件的时候, 获取这个组件在不同的地方有少量的更改, 如果去重写组件是一件不明智的事情

通过slot插槽向组件内部指定位置传递内容, 完成这个复用组件在不同场景的应用

比如布局组件、表格列、下拉选、弹框显示内容等

[vue solt插槽详解]()

---

## 21.什么是虚拟DOM?如何实现一个虚拟DOM?说说你的思路

`虚拟DOM` (`Virtual DOM`)这个概念相信大家都不陌生, 从 `React` 到 `Vue` , `虚拟DOM` 为这两个框架都带来了跨平台的能力(`React-Native` 和 `Weex`)

实际上它只是一层对真实DOM的抽象, 以JavaScript 对象 (`VNode 节点`) 作为基础的树, 用对象的属性来描述节点, 最终可以通过一系列操作使这棵树映射到真实环境上

在Javascript对象中, 虚拟DOM 表现为一个` Object对象`。并且最少包含标签名 `(tag)`、属性 `(attrs)` 和子元素对象 `(children)` 三个属性, 不同框架对这三个属性的名命可能会有差别

创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中, 所以虚拟DOM对象的节点与真实DOM的属性一一照应

>很多人认为虚拟 DOM 最大的优势是 diff 算法, 减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势, 但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程, 实现了跨平台的能力, 而不仅仅局限于浏览器的 DOM, 可以是安卓和 IOS 的原生组件, 可以是近期很火热的小程序, 也可以是各种GUI

TODO: 如何实现一个虚拟DOM?说说你的思路?

[JavaScript如何实现一个虚拟DOM]()

---

## 22.Vue项目中有封装过axios吗?主要是封装哪方面的?

主要根据以下方面来封装

封装的同时, 你需要和 后端协商好一些约定, 请求头, 状态码, 请求超时时间.......

- 设置接口请求前缀: 根据开发、测试、生产环境的不同, 前缀需要加以区分
- 请求头: 来实现一些具体的业务, 必须携带一些参数才可以请求(例如: 会员业务)
- 状态码: 根据接口返回的不同status, 来执行不同的业务, 这块需要和后端约定好
- 请求方法: 根据get、post等方法进行一个再次封装, 使用起来更为方便
- 请求拦截器: 根据请求的请求头设定, 来决定哪些请求可以访问
- 响应拦截器: 这块就是根据 后端`返回来的状态码判定执行不同业务

利用`node`环境变量来作判断, 用来区分开发、测试、生产环境

```js showLineNumbers copy
if (process.env.NODE_ENV === 'development') {
  axios.defaults.baseURL = 'http://dev.xxx.com'
} else if (process.env.NODE_ENV === 'production') {
  axios.defaults.baseURL = 'http://prod.xxx.com'
}
```

在本地调试的时候, 还需要在`vue.config.js`文件中配置devServer实现代理转发, 从而实现跨域

```js showLineNumbers copy
module.exports = {
  devServer: {
    proxy: {
      '/proxyApi': {
        target: 'http://dev.xxx.com',
        changeOrigin: true,
        pathRewrite: {
          '/proxyApi': ''
        }
      }
    }
  }
}
```

大部分情况下, 请求头都是固定的, 只有少部分情况下, 会需要一些特殊的请求头, 这里将普适性的请求头作为基础配置。当需要特殊请求头时, 将特殊请求头作为参数传入, 覆盖基础配置

```js showLineNumbers copy
const service = axios.create({
  ...
  timeout: 30000,  // 请求 30s 超时
  headers: {
    get: {
      'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'
      // 在开发中, 一般还需要单点登录或者其他功能的通用请求头, 可以一并配置进来
    },
    post: {
      'Content-Type': 'application/json;charset=utf-8'
      // 在开发中, 一般还需要单点登录或者其他功能的通用请求头, 可以一并配置进来
    }
  },
})
```

请求拦截器可以在每个请求里加上token, 做了统一处理后维护起来也方便

```js showLineNumbers copy
// 请求拦截器
axios.interceptors.request.use(
  config => {
    // 每次发送请求之前判断是否存在token
    // 如果存在, 则统一在http请求的header都加上token, 这样后台根据token判断你的登录情况, 此处token一般是用户完成登录后储存到localstorage里的
    token && (config.headers.Authorization = token)
    return config
  },
  error => {
    return Promise.error(error)
  }
)
```

响应拦截器可以在接收到响应后先做一层操作, 如根据状态码判断登录状态、授权

```js showLineNumbers copy
// 响应拦截器
axios.interceptors.response.use(
  response => {
    // 如果返回的状态码为200, 说明接口请求成功, 可以正常拿到数据
    // 否则的话抛出错误
    if (response.status === 200) {
      if (response.data.code === 511) {
        // 未授权调取授权接口
      } else if (response.data.code === 510) {
        // 未登录跳转登录页
      } else {
        return Promise.resolve(response)
      }
    } else {
      return Promise.reject(response)
    }
  },
  error => {
    // 我们可以在这里对异常状态作统一处理
    if (error.response.status) {
      // 处理请求失败的情况
      // 对不同返回码对相应处理
      return Promise.reject(error.response)
    }
  }
)
```

---

## 23.是怎么处理vue项目中的错误的?

任何一个框架, 对于错误的处理都是一种必备的能力

在Vue 中, 则是定义了一套对应的错误处理规则给到使用者, 且在源代码级别, 对部分必要的过程做了一定的错误处理。

主要的错误来源包括: 

- 后端接口错误
- 代码中本身逻辑错误

**后端接口错误**

通过axios的interceptor实现网络请求的response先进行一层拦截

**代码逻辑问题**

#全局设置错误处理

设置全局错误处理函数

```js showLineNumbers copy
Vue.config.errorHandler = function (err, vm, info) {
  // handle error
  // `info` 是 Vue 特定的错误信息, 比如错误所在的生命周期钩子
  // 只在 2.2.0+ 可用
}
```

---

## 24.vue要做权限管理该怎么做?如果控制到按钮级别的权限怎么做?

前端权限控制可以分为四个方面: 

- 接口权限
- 按钮权限
- 菜单权限
- 路由权限

**接口权限**

接口权限目前一般采用jwt的形式来验证, 没有通过的话一般返回401, 跳转到登录页面重新进行登录

登录完拿到token, 将token存起来, 通过axios请求拦截器进行拦截, 每次请求的时候头部携带token

```js showLineNumbers copy
axios.interceptors.request.use(config => {
  config.headers['token'] = cookie.get('token')
  return config
})
axios.interceptors.response.use(res => {}, { response } => {
  if (response.data.code === 40099 || response.data.code === 40098) { //token过期或者错误
    router.push('/login')
  }
})
```

**按钮权限**

通过自定义指令进行按钮权限的判断

首先配置路由

```js showLineNumbers copy
{
  path: '/permission',
  component: Layout,
  name: '权限测试',
  meta: {
    btnPermissions: ['admin', 'supper', 'normal']
  },
  //页面需要的权限
  children: [{
    path: 'supper',
    component: _import('system/supper'),
    name: '权限测试页',
    meta: {
      btnPermissions: ['admin', 'supper']
    } //页面需要的权限
  },
  {
    path: 'normal',
    component: _import('system/normal'),
    name: '权限测试页',
    meta: {
      btnPermissions: ['admin']
    } //页面需要的权限
  }]
}
```

自定义权限鉴定指令

```js showLineNumbers copy
import Vue from 'vue'
/**权限指令**/
const has = Vue.directive('has', {
  bind: function (el, binding, vnode) {
    // 获取页面按钮权限
    let btnPermissionsArr = [];
    if (binding.value) {
      // 如果指令传值, 获取指令参数, 根据指令参数和当前登录人按钮权限做比较。
      btnPermissionsArr = Array.of(binding.value);
    } else {
      // 否则获取路由中的参数, 根据路由的btnPermissionsArr和当前登录人按钮权限做比较。
      btnPermissionsArr = vnode.context.$route.meta.btnPermissions;
    }
    if (!Vue.prototype.$_has(btnPermissionsArr)) {
      el.parentNode.removeChild(el);
    }
  }
});

// 权限检查方法
Vue.prototype.$_has = function (value) {
  let isExist = false;
  // 获取用户按钮权限
  let btnPermissionsStr = sessionStorage.getItem("btnPermissions");
  if (btnPermissionsStr == undefined || btnPermissionsStr == null) {
    return false;
  }
  if (value.indexOf(btnPermissionsStr) > -1) {
    isExist = true;
  }
  return isExist;
};

export {has}
```

在使用的按钮中只需要引用`v-has`指令

```html showLineNumbers copy
<el-button @click='editClick' type="primary" v-has>编辑</el-button>
```

---

## 25.说说你对keep-alive的理解是什么?

`keep-alive`是vue中的内置组件, 能在组件切换过程中将状态保留在内存中, 防止重复渲染DOM

`keep-alive` 包裹动态组件时, 会缓存不活动的组件实例, 而不是销毁它们

`keep-alive`可以设置以下props属性: 

- include - 字符串或正则表达式。只有名称匹配的组件会被缓存
- exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存
- max - 数字。最多可以缓存多少组件实例

关于keep-alive的基本用法

```vue showLineNumbers copy
<tempalte>
  <keep-alive>
    <component :is="view"></component>
  </keep-alive>
</tempalte>
```

使用`includes`和`exclude`

```vue showLineNumbers copy
<tempalte>
  <keep-alive include="a,b">
    <component :is="view"></component>
  </keep-alive>

  <!-- 正则表达式 (使用 `v-bind`) -->
  <keep-alive :include="/a|b/">
    <component :is="view"></component>
  </keep-alive>

  <!-- 数组 (使用 `v-bind`) -->
  <keep-alive :include="['a', 'b']">
    <component :is="view"></component>
  </keep-alive>
</tempalte>
```

匹配首先检查组件自身的 `name` 选项, 如果 `name` 选项不可用, 则匹配它的局部注册名称 (父组件 `components` 选项的键值), 匿名组件不能被匹配

设置了 `keep-alive` 缓存的组件, 会多出两个生命周期钩子(activated与deactivated)

- 首次进入组件时: `beforeRouteEnter` >` beforeCreate `> `created` > `mounted` > `activated` > ... ... >` beforeRouteLeave` > `deactivated`
- 再次进入组件时: `beforeRouteEnter` > `activated` > ... ... > `beforeRouteLeave` > `deactivated`

**使用原则: 当我们在某些场景下不需要让页面重新加载时我们可以使用keepalive**

举个栗子:

当我们从`首页` –> `列表页` –> `商详页` –> `再返回`, 这时候列表页应该是需要`keep-alive`

在路由中设置`keepAlive`属性判断是否需要缓存

```js showLineNumbers copy
{
  path: 'list',
  name: 'itemList', // 列表页
  component (resolve) {
    require(['@/pages/item/list'], resolve)
  },
  meta: {
    keepAlive: true,
    title: '列表页'
  }
}
```

使用`<keep-alive>`

```vue showLineNumbers copy
<div id="app" class='wrapper'>
  <keep-alive>
    <!-- 需要缓存的视图组件 --> 
    <router-view v-if="$route.meta.keepAlive"></router-view>
  </keep-alive>

  <!-- 不需要缓存的视图组件 -->
  <router-view v-if="!$route.meta.keepAlive"></router-view>
</div>
```

>vue性能优化的一种方式

---

## 26.你对SPA单页面的理解,它的优缺点分别是什么?如何实现SPA应用呢

**SPA**

SPA(single-page application), 翻译过来就是单页应用SPA是一种网络应用程序或网站的模型, 它通过动态重写当前页面来与用户交互, 这种方法避免了页面之间切换打断用户体验在单页应用中, 所有必要的代码(HTML、JavaScript和CSS)都通过单个页面的加载而检索, 或者根据需要(通常是为响应用户操作)动态装载适当的资源并添加到页面页面在任何时间点都不会重新加载, 也不会将控制转移到其他页面举个例子来讲就是一个杯子, 早上装的牛奶, 中午装的是开水, 晚上装的是茶, 我们发现, 变的始终是杯子里的内容, 而杯子始终是那个杯子

我们熟知的JS框架如`react`、`vue`、`angular`、`ember`都属于`SPA`

**MPA**

上面大家已经对单页面有所了解了, 下面来讲讲多页应用MPA(MultiPage-page application), 翻译过来就是多页应用在MPA中, 每个页面都是一个主页面, 都是独立的当我们在访问另一个页面的时候, 都需要重新加载html、css、js文件

**SPA和MPA的区别**

|-|单页面应用(SPA)|多页面应用(MPA)|
|:---|:---|:---|
|组成|一个主页面和多个页面片段|多个主页面|
|刷新方式|局部刷新|整页刷新|
|url模式|哈希模式|历史模式|
|SEO搜索引擎优化|难实现, 可使用SSR方式改善|容易实现|
|数据传递|容易|通过url、cookie、localStorage等传递|
|页面切换|速度快, 用户体验良好|切换加载资源, 速度慢, 用户体验差|
|维护成本|相对容易|相对复杂|

**单页应用优缺点**

优点: 

- 具有桌面应用的即时性、网站的可移植性和可访问性
- 用户体验好、快, 内容的改变不需要重新加载整个页面
- 良好的前后端分离, 分工更明确

缺点: 

- 不利于搜索引擎的抓取
- 首次渲染速度相对较慢

**实现一个SPA原理**

1. 监听地址栏中hash变化驱动界面变化
2. 用pushsate记录浏览器的历史, 驱动界面发送变化

[JavaScript实现一个单页面应用]()

---

## 27.SPA首屏加载速度慢的怎么解决?

首屏时间(First Contentful Paint), 指的是浏览器从响应用户输入网址地址, 到首屏内容渲染完成的时间, 此时整个网页不一定要全部渲染完成, 但需要展示当前视窗需要的内容

首屏加载可以说是用户体验中最重要的环节

**关于计算首屏时间**

利用`performance.timing`提供的数据: 

通过`DOMContentLoad`或者`performance`来计算出首屏时间

```js showLineNumbers copy
// 方案一: 
document.addEventListener('DOMContentLoaded', (event) => {
    console.log('first contentful painting');
});
// 方案二: 
performance.getEntriesByName("first-contentful-paint")[0].startTime

// performance.getEntriesByName("first-contentful-paint")[0]
// 会返回一个 PerformancePaintTiming的实例, 结构如下: 
{
  name: "first-contentful-paint",
  entryType: "paint",
  startTime: 507.80000002123415,
  duration: 0,
};
```

**加载慢的原因**

在页面渲染的过程, 导致加载速度慢的因素可能如下: 

- 网络延时问题
- 资源文件体积是否过大
- 资源是否重复发送请求去加载了
- 加载脚本的时候, 渲染内容堵塞了

**解决方案**

常见的几种SPA首屏优化方式

- 减小入口文件积
- 静态资源本地缓存
- UI框架按需加载
- 图片资源的压缩
- 组件重复打包
- 开启GZip压缩
- 使用SSR

[解决SPA首屏加载慢的几个优化手段]()

---

## 28.vue项目本地开发完成后部署到服务器后报404是什么原因呢?

TODO

## 29.SSR解决了什么问题?有做过SSR吗?你是怎么做的?

`Server-Side Rendering` 我们称其为SSR, 意为服务端渲染

指由服务侧完成页面的 HTML 结构拼接的页面处理技术, 发送到浏览器, 然后为其绑定状态与事件, 成为完全可交互页面的过程

先来看看Web3个阶段的发展史: 

- 传统服务端渲染SSR
- 单页面应用SPA
- 服务端渲染SSR


**SSR主要解决了以下两种问题**

- seo: 搜索引擎优先爬取页面HTML结构, 使用ssr时, 服务端已经生成了和业务想关联的HTML, 有利于seo
- 首屏呈现渲染: 用户无需等待页面所有js加载完成就可以看到页面视图(压力来到了服务器, 所以需要权衡哪些用服务端渲染, 哪些交给客户端)

但是使用SSR同样存在以下的缺点: 

- 复杂度: 整个项目的复杂度
- 库的支持性, 代码兼容
- 性能问题
  - 每个请求都是n个实例的创建, 不然会污染, 消耗会变得很大
  - 缓存 node serve、 nginx判断当前用户有没有过期, 如果没过期的话就缓存, 用刚刚的结果。
  - 降级: 监控cpu、内存占用过多, 就spa, 返回单个的壳
- 服务器负载变大, 相对于前后端分离服务器只需要提供静态资源来说, 服务器负载更大, 所以要慎重使用

[JavaScript实现一个SSR框架]()

---

## 30.vue3有了解过吗?能说说跟vue2的区别吗?

- 写法上的区别: vue2使用的是options(选项)Api,vue3的是composition Api(当然vue3也兼容composition api)。options Api中methods, compute, data等api都是分散的。而composition api中的代码是根据逻辑功能来组织的,我们可以将一个功能所定义的methods, compute, data等api会放在一起,让我们可以更灵活地组合组件逻辑。
- vue2将响应式数据放到data函数中,而vue3则是使用ref和reactive将数据声明为响应式
- 响应式实现方式:vue2中是通过Object.defineProperty对数据劫持实现的,vue3中则是使用Proxy对数据代理实现的。
- 生命周期区别:vue3中将beforeCreate和created合并到了setup函数中
- 根节点: vue3组件允许多个根节点,而vue2只允许一个
- 内置组件: vue3新增了传送组件Teleport和异步依赖处理组件Suspense

## 31.说说vue3的变化

1. 生命周期

对于生命周期来说, 整体上变化不大, 只是大部分生命周期钩子名称上 + “on”, 功能上是类似的。不过有一点需要注意, Vue3 在组合式API(Composition API, 下面展开)中使用生命周期钩子时需要先引入, 而 Vue2 在选项API(Options API)中可以直接调用生命周期钩子, 如下所示。

```html showLineNumbers copy
<!-- vue3 -->
<script setup>
  // 使用前需引入生命周期钩子
  import { onMounted } from 'vue';
  onMounted(() => {
    // ...
  });
  // 可将不同的逻辑拆开成多个onMounted, 依然按顺序执行, 不会被覆盖
  onMounted(() => {
    // ...
  });

</script>

<!-- vue2 -->
<script>     
export default {
  // 直接调用生命周期钩子
  mounted() {        
    // ...         
  },
}
</script>
```
vue2和vue3常用生命周期对比如下表所示。

|vue2|vue3|
|:---|:---|
|beforeCreate|-|
|created|-|
|beforeMount|onBeforeMount|
|mounted|onMounted|
|beforeUpdate|onBeforeUpdate|
|updated|onUpdated|
|beforeDestroy|onBeforeUnmount|
|destroyed|onUnmounted|

>setup 是围绕 beforeCreate 和 created 生命周期钩子运行的, 所以不需要显式地去定义

---

2. 多根节点

熟悉 Vue2 的朋友应该清楚, 在模板中如果使用多个根节点时会报错, 如下所示

```vue showLineNumbers copy
<!-- vue2中在template里存在多个根节点会报错 -->
<template>
  <header></header>
  <main></main>
  <footer></footer>
</template>

<!-- 只能存在一个根节点, 需要用一个<div>来包裹着 -->
<template>
  <div>
    <header></header>
    <main></main>
    <footer></footer>
  </div>
</template>
```

但是, Vue3 支持多个根节点, 也就是 fragment。即以下多根节点的写法是被允许的

```vue showLineNumbers copy
<template>
  <header></header>
  <main></main>
  <footer></footer>
</template>
```

3. Composition API

Vue2 是选项API(Options API), 一个逻辑会散乱在文件不同位置(data、props、computed、watch、生命周期钩子等), 导致代码的可读性变差。当需要修改某个逻辑时, 需要上下来回跳转文件位置。

Vue3 组合式API(Composition API)则很好地解决了这个问题, 可将同一逻辑的内容写到一起, 增强了代码的可读性、内聚性, 其还提供了较为完美的逻辑复用性方案。

4. 异步组件(Suspense)

Vue3 提供 Suspense 组件, 允许程序在等待异步组件加载完成前渲染兜底的内容, 如 loading , 使用户的体验更平滑。使用它, 需在模板中声明, 并包括两个命名插槽: default 和 fallback。Suspense 确保加载完异步内容时显示默认插槽, 并将 fallback 插槽用作加载状态。

```vue showLineNumbers copy
<tempalte>
  <suspense>
    <template #default>
      <List />
    </template>
    <template #fallback>
      <div>
        Loading...
      </div>
    </template>
  </suspense>
</template>
```

在 List 组件(有可能是异步组件, 也有可能是组件内部处理逻辑或查找操作过多导致加载过慢等)未加载完成前, 显示 Loading...(即 fallback 插槽内容), 加载完成时显示自身(即 default 插槽内容)。

5. Teleport

Vue3 提供 Teleport 组件可将部分 DOM 移动到 Vue app 之外的位置。比如项目中常见的 Dialog 弹窗

```vue showLineNumbers copy
<button @click="dialogVisible = true">显示弹窗</button>
<teleport to="body">
  <div class="dialog" v-if="dialogVisible">
    我是弹窗, 我直接移动到了body标签下  </div>
</teleport>
```

6. 响应式原理

Vue2 响应式原理基础是 Object.defineProperty;Vue3 响应式原理基础是 Proxy

7. 虚拟DOM

Vue3 相比于 Vue2, 虚拟DOM上增加 patchFlag 字段。我们借助Vue3 Template Explorer来看

8. 事件缓存

Vue3 的cacheHandler可在第一次渲染后缓存我们的事件。相比于 Vue2 无需每次渲染都传递一个新函数。

9. Diff算法优化

结合上文与源码, patchFlag 帮助 diff 时区分静态节点, 以及不同类型的动态节点。一定程度地减少节点本身及其属性的比对

10. 打包优化

Tree-shaking: 模块打包 webpack、rollup 等中的概念。移除 JavaScript 上下文中未引用的代码。主要依赖于 import 和 export 语句, 用来检测代码模块是否被导出、导入, 且被 JavaScript 文件使用。

以 nextTick 为例子, 在 Vue2 中, 全局API暴露在Vue实例上, 即使未使用, 也无法通过 tree-shaking 进行消除

```js showLineNumbers copy
import Vue from 'vue';
Vue.nextTick(() => {
  // 一些和DOM有关的东西
});
```

Vue3 中针对全局和内部的API进行了重构, 并考虑到 tree-shaking 的支持。因此, 全局API现在只能作为ES模块构建的命名导出进行访问。

```js showLineNumbers copy
import { nextTick } from 'vue';   // 显式导入
nextTick(() => {
  // 一些和DOM有关的东西
});
```

通过这一更改, 只要模块绑定器支持 tree-shaking, 则Vue应用程序中未使用的 api 将从最终的捆绑包中消除, 获得最佳文件大小。

受此更改影响的全局API如下所示。

- Vue.nextTick
- Vue.observable (用 Vue.reactive 替换)
- Vue.version
- Vue.compile (仅全构建)
- Vue.set (仅兼容构建)
- Vue.delete (仅兼容构建)

内部API也有诸如 transition、v-model 等标签或者指令被命名导出。只有在程序真正使用才会被捆绑打包。Vue3 将所有运行功能打包也只有约22.5kb, 比 Vue2 轻量很多

11. TypeScript支持

Vue3 由 TypeScript 重写, 相对于 Vue2 有更好的 TypeScript 支持。

- Vue2 Options API 中 option 是个简单对象, 而 TypeScript 是一种类型系统, 面向对象的语法, 不是特别匹配。
- Vue2 需要vue-class-component强化vue原生组件, 也需要vue-property-decorator增加更多结合Vue特性的装饰器, 写法比较繁琐。

---

## 32.Vue的两个核心

**1. 数据驱动, 也叫双向数据绑定**

`Vue`数据观测原理在实现上, 是利用了es5的 `Object.defiedProperty`和存储器属性: `getter`和`setter`(所以只兼容IE 9及以上版本), 主要核心是VM, 也就是ViewModel, 保证数据和视图的一致性

**2. 组件系统**

- 1、模板(template): 模板声明了数据和最终展现给用户的DOM之间的映射关系。
- 2、初始数据(data): 一个组件的初始数据状态, 对于可复用的组件来说, 这通常是私有的状态。
- 3、接受的外部参数(props): 组件之间通过参数来进行数据的传递和共享
- 4、方法(methods): 对数据的改动操作一般都在组件的方法内进行
- 5、生命周期钩子函数: 一个组件会触发多个生命周期钩子函数
- 6、私有资源(assets): Vue当中将用户自定义的指令、过滤器、组件等统称为资源。一个组件可以生命自己的私有资源, 私有资源只有该组件和他的子组件可以调用

---

## 33.Vue常用指令

`v-if`: 根据条件真假判断是否渲染元素, 在切换时元素及他的数据绑定/组件被销毁并重建

`v-show`: 根据条件真假判断, 切换元素的css中display的属性 none/block

`v-for`: 循环指令

`v-bind`: 动态绑定一个或多个特性, v-bind:name= , 简写 :name=

`v-on`: 监听执行元素的事件, 比如点击事件 v-on:name,简写 @name

`v-model`: 实现表单输入和应用状态之间的双向绑定

`v-pre`: 跳跳过这个元素和它的子元素的编译过程。一些静态的内容不需要编辑加这个指令可以加快编辑

`v-once`: 只渲染元素和组件一次

`v-html`: 更新元素的innerHTML

`v-text`: 更新元素的textContent

---

## 34.vue常用修饰符

**v-on常用修饰符**

- `.stop` - 调用event.stopPropagation() 禁止事件冒泡
- `.prevent` - 调用event.preventDefault() 阻止事件默认行为
- `.capture` - 添加事件侦听器时使用capture模式(即内部元素触发的事件先在此处理, 然后才交由内部元素进行处理)
- `.self` - 当事件是从侦听器绑定的元素本身触发时才触发回调
- `.{keycde|keyalias}` - 只有当事件是从特定按键触发时才触发的回调 如.enter
- `.native` - 监听组件根元素的原生事件
- `.once` - 只触发一次回调
- `.left` - 只当点击鼠标左键时触发(2.2.0)
- `.right`- 鼠标右键时触发
- `.middle` - 鼠标中键时触发
- `.passive` - 以 `{passive:true}` 模式添加侦听器 (2.3.0)

**v-bind常用修饰符**

- `.prop` - 被用于绑定DOM属性(property)
- `.camel` - 将kebab-case 特性名转为cameCase
- `.sync` - 语法糖, 会拓展成一个更新父组件绑定值得v-on侦听器

**v-model常用指令**

- `.lazy` - 取代input监听change事件
- `.number` - 输入字符串转为数字
- `.trim` - 输入首尾空格过滤

---

## 35.v-on可以监听多个方法吗

可以

1. 使用`v-on="{ method1(), method2()}"`的方式, 这种方式可以在同一个元素上绑定多个方法。
2. 另一种高级用法是将所有需要传递给子组件的事件函数存储在一个数组中, 然后在子组件中使用`v-on="$listener"`的方式来注册这些方法。

---

## 36.vue中key的作用?为什么不推介使用index作为key?

**key 的特殊属性主要用在 Vue的虚拟DOM算法, 在新旧nodes对比时辨识VNodes。**

如果不使用key, Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。

使用key, 它会基于key的变化重新排列元素顺序, 并且会移除key不存在的元素

1. key的作用主要是为了高效的更新虚拟DOM(使用key, 它会基于key的变化重新排列元素顺序, 并且会移除key不存在的元素)

2. 当以数组的下标index作为index值时, 其中一个元素(如增删改查)发生了变化就有可能导致所有元素的key值发生变化

---

## 37.vue事件中如何使用event对象

vue传递事件对象 `$event` 

有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 `$event` 把它传入方法

例子: 

```vue showLineNumbers copy
<template>
  <a href="javascript:;" data-id="1" @click="clickEvent($event)">event</a>
</template>

<script>
export default {
  methods: {
    clickEvent(event){
      // 获取data-id
      console.log(event.target.dataset.id)
      // 阻止事件冒泡
      event.stopPropagation()
    }
  }
}
</script>
```

## 38.异步更新队列

Vue在观察到数据变化时并不是直接更新DOM, 而是开启一个队列, 并缓冲在同一事件循环中发生的所有数据变更。
所以同一个watcher被多次触发, 只会添加到队列一次, 因此可以去除重复数据可以避免不必要的计算和DOM操作

Vue在内部对异步队列尝试使用原生的Promise.then 、 MutationObserver和setImmediate,
如果以上都不支持, 则采用setTimeout(fn,0)代替

---

## 39.vue组件通信方式

|方式|Vue2|Vue3|
|:---|:---|:---|
|父传子|props|props|
|子传父|$emit|emits|
|父传子|$attrs|attrs|
|子传父|$listeners|无(合并到 attrs方式)|
|父传子|provide/inject|provide/inject|
|子组件访问父组件|$parent|无|
|父组件访问子组件|$children|无|
|父组件访问子组件|$ref|expose&ref|
|兄弟组件传值|EventBus|mitt|

[参考](/vue/vue2/vue_1)

---

## 40.computed和watch区别

**computed的特点**

- 支持缓存, 默认走缓存, 多次调用, 只会执行一次计算。只有依赖的数据发生改变, 才会重新计算
- 不支持异步, 如果有异步操作, 无法监听
- 属性值为函数, 默认使用get方法, 当数据改变时, 会调用set方法
- 主要解决模版中放入过多的逻辑导致不好维护的问题

**watch的特点**

- 不支持缓存, 只要数据发生变化, 就会触发相应的操作;
- 支持异步监听;
- 接收两个参数, 第一个是最新值, 第二个是之前的值;
- 还有两个其他参数: deep: 默认false, 深度监听, immediate: 默认false, 初始化时执行回调函数;

**总结**

- computed计算属性, 他依赖其他属性值, 有缓存, 只有依赖的值发生变化才会去重新计算, 但是不能异步;
- watch监听, 监听数据的变化, 无缓存, 数据变化就会执行回调, 可以异步;

**使用场景**

- 当一个值受多个属性影响的时候使用computed
- 当一条数据的更改影响到多条数据的时候使用watch

[计算属性computed和watch监视的使用和区别](/vue/vue2/vue_2)

---

## 41.Object.defineProperty 和 proxy的区别

1. `Object.defineProperty`只能劫持对象的属性, 需要遍历对象的每个属性, 如果属性值也是对象, 则需要深度遍历, 而proxy是直接代理对象, 不需要遍历操作
2. `Object.defineProperty`对新增属性需要手动进行observe, 因为defineproperty劫持的是对象的属性, 所以新增属性时, 需要重新遍历对象, 再对新增属性再使用defineproperty进行劫持。而proxy可以直接监听对象属性的添加

也是因为这个原因, vue2.0在给data中的数组或对象新增属性时, 需要用vm.$set来保证新增属性的响应

**简单的说**

definedProperty的缺陷

- 不能监听数组变化
- 必须遍历对象的每个属性
- 必须深层遍历嵌套对象

**proxy对比definedProperty的优点**

- proxy监听的是整个对象而不是对象的某个属性
- proxy可以监听数组的变化
- proxy结果返回一个新的对象, 可以直接操作新对象, 而不是像definedproperty遍历属性进行修改
- proxy相对性能更好
- proxy对浏览器的兼容性不够

---


## 42.vue slot插槽

**基本用法**

在Vue中, 插槽被用于在组件中定义可变的部分。组件可以将其内部的内容暴露出去, 允许父级组件在使用该组件时传入自定义内容。这种传递的内容可以是任何类型的Vue实例, 包括文字、HTML标签、其他组件等。

插槽的基本用法是在子组件中定义`<slot></slot>`元素。这个元素将作为一个占位符, 用于接收父级组件传递过来的内容。具名插槽:  具名插槽允许你为组件的不同部分提供不同的内容。在组件模板中, 你可以通过`<slot>`元素的name属性来定义具名插槽。例如:  

```vue showLineNumbers copy
// 子组件 ChildComponent.vue
<template>
  <div>
    <h1>子组件</h1>
    <slot></slot>
  </div>
</template>
```

```vue showLineNumbers copy
// 父组件 ParentComponent.vue
<template>
  <div>
    <h1>父组件</h1>
    <ChildComponent>
      <p>这是插槽的内容</p>
    </ChildComponent>
  </div>
</template>
```

在上面的例子中, 我们在子组件中定义了一个插槽, 然后在父组件中使用`<ChildComponent>`标签, 并在标签内部放置了一个`<p>`标签作为插槽的内容。当父组件被渲染时, 插槽的内容将被替换为实际传入的内容。

**具名插槽**

在上面的例子中, 我们使用的是默认插槽, 也就是没有给插槽命名。在某些情况下, 我们可能需要定义多个插槽, 并且通过名称来区分它们。这就是具名插槽的用法。

具名插槽可以通过在`<slot>`元素上添加`name`属性来定义。下面是一个具名插槽的例子: 

```vue showLineNumbers copy
// 子组件 ChildComponent.vue
<template>
  <div>
    <h1>子组件</h1>
    <slot name="header"></slot>
    <slot></slot>
    <slot name="footer"></slot>
  </div>
</template>
```

```vue showLineNumbers copy
// 父组件 ParentComponent.vue
<template>
  <div>
    <h1>父组件</h1>
    <ChildComponent>
      <template v-slot:header>
        <h2>这是头部插槽的内容</h2>
      </template>
      <p>这是默认插槽的内容</p>
      <template v-slot:footer>
        <footer>这是尾部插槽的内容</footer>
      </template>
    </ChildComponent>
  </div>
</template>
```

在上面的例子中, 我们在子组件中定义了三个插槽, 并分别给它们起了名称。在父组件中, 我们使用`v-slot`指令来指定不同的插槽, 并在`<template>`中放置插槽的内容。

**作用域插槽**

除了基本的插槽功能, Vue还提供了一种更强大的插槽功能, 即作用域插槽。作用域插槽允许子组件向父组件传递数据, 实现更为灵活的组件交互。

作用域插槽使用`<slot>`元素中的属性来传递数据。下面是一个作用域插槽的例子: 

```vue showLineNumbers copy
// 子组件 ChildComponent.vue
<template>
  <div>
    <h1>子组件</h1>
    <slot v-bind:user="user"></slot>
  </div>
</template>
 
<script>
export default {
  data() {
    return {
      user: {
        name: 'John Doe',
        age: 26
      }
    }
  }
}
</script>
```

```vue showLineNumbers copy
// 父组件 ParentComponent.vue
<template>
  <div>
    <h1>父组件</h1>
    <ChildComponent>
      <template v-slot:default="slotProps">
        <h2>用户信息</h2>
        <p>{{ slotProps.user.name }}</p>
        <p>{{ slotProps.user.age }}</p>
      </template>
    </ChildComponent>
  </div>
</template>
```

在上面的例子中, 我们在子组件中定义了一个插槽, 并使用`v-bind`指令将`user`对象传递给插槽。在父组件中, 我们使用带有`slotProps`名称的属性来接收子组件传递的数据, 并在插槽中使用。

**插槽的高级用法**

除了基本和具名插槽以及作用域插槽之外, Vue的插槽还有一些高级用法, 如动态插槽、作用域插槽的默认值以及插槽的替代内容。

动态插槽允许在运行时动态选择要使用的插槽。通过使用`v-slot`的值作为动态属性值, 可以根据需要选择不同的插槽。下面是一个动态插槽的例子: 

```vue showLineNumbers copy
// 子组件 ChildComponent.vue
<template>
  <div>
    <h1>子组件</h1>
    <slot :name="slotName"></slot>
  </div>
</template>
 
<script>
export default {
  data() {
    return {
      slotName: 'header'
    }
  }
}
</script>
```

```vue showLineNumbers copy
// 父组件 ParentComponent.vue
<template>
  <div>
    <h1>父组件</h1>
    <ChildComponent>
      <template v-slot:[slotName]>
        <h2>{{ slotName }}插槽的内容</h2>
      </template>
    </ChildComponent>
    <button @click="changeSlotName">切换插槽</button>
  </div>
</template>
 
<script>
export default {
  data() {
    return {
      slotName: 'header'
    }
  },
  methods: {
    changeSlotName() {
      this.slotName = this.slotName === 'header' ? 'footer' : 'header'
    }
  }
}
</script>
```

在上面的例子中, 我们使用了`v-slot`的值作为动态属性值, 根据当前的`slotName`选择不同的插槽。点击按钮时, `slotName`的值会发生变化, 从而切换到不同的插槽。

**注意事项: **

- 如果未提供任何内容来填充插槽, 则插槽内的内容将被视为默认内容, 并在组件模板中显示。
- 你也可以使用特殊的语法糖#来定义插槽, 例如`<template #header>`等价于`<template v-slot:header>`。

插槽是 Vue.js 的一个非常强大和灵活的特性, 它使得组件的结构更加可配置和可复用。通过合理使用插槽, 你可以轻松地扩展组件的功能并满足各种不同的使用场景。

---

## 43.vue props如何自定义验证

```js showLineNumbers copy
export default {
  props: {
    num: {
      default: 1,
      validator: function(value) {
        // 返回false则验证不通过, 报错 
        return value <= 2;
      }  
    }
  }
}
```

---

## 44.如何让CSS只在当前组件中起作用

Vue可以通过使用scoped属性来限制样式仅应用于特定的组件。

在单文件组件(.vue)中, 将style标签添加scoped属性, 示例如下所示: 

```vue showLineNumbers copy
<template>
  <!-- 模板内容 -->
</template>
 
<script>
export default {
  // 组件逻辑
}
</script>
 
<style scoped>
/* CSS样式 */
</style>
```

这样设置后, 该组件的CSS样式就会被局部化, 不会影响其他组件或全局样式。

---

## 45.相同路由组件如何重新渲染

Vue默认不会对相同的路由的切换做重新渲染

如果需要重新渲染, 可以添加key

```vue showLineNumbers copy
<template>
  <router-view :key="$route.path"></router-view>
</tempalte>
```

---

## 46.如何获取data某个数值的初始值

data的属性改变后, 可以通过`this.$options.data().x` 获取初始值

---

## 47.created和mounted的区别

created和mounted都是Vue生命周期钩子函数, 但它们的执行时机不同。

created是在实例创建完成后立即执行的钩子函数, 此时组件的DOM节点还未生成, 数据也还未渲染到页面上。

mounted是在组件挂载到页面上后执行的钩子函数, 此时组件的DOM节点已经生成, 数据也已经渲染到页面上。

因此, 如果需要在组件创建时进行一些数据初始化的操作, 可以使用created钩子函数;如果需要在组件挂载到页面上后进行一些DOM操作或与后端交互的操作, 可以使用mounted钩子函数。

---

## 48.v-model语法糖是怎么实现的

`v-model`是`value` + `input`的语法糖, 是`v-band`和`v-on`的简洁写法。`v-model`就实现了双向数据绑定, 实际上它就是通过Vue提供的事件机制。即在子组件通过`$emit()`触发一个事件, 在父组件使用`v-model`即可

---

## 49.vue eventbus(事件总线)具体是怎么实现的

`EventBus` 又称为事件总线。在Vue中可以使用 `EventBus` 来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心, 可以向该中心注册发送事件或接收事件, 所以组件都可以上下平行地通知其他组件, 但也就是太方便所以若使用不慎, 就会造成难以维护的"灾难", 因此才需要更完善的`Vuex`作为状态管理中心, 将通知的概念上升到共享状态层次。

[Vue事件总线(EventBus)使用详细介绍](/vue/vue2/vue_3)

---

## 50.说说vue操作真实dom性能瓶颈

1. **DOM 操作的代价** : 直接操作 DOM 是昂贵的操作, 因为它涉及到浏览器渲染引擎的重新计算、布局和绘制。Vue 通过虚拟 DOM 尽量减少了对真实 DOM 的操作, 但在某些情况下, 如使用 ref 或 $el 直接访问 DOM 元素时, 我们可能会不自觉地触发大量的 DOM 操作, 从而影响性能。
2. **异步更新队列** : Vue 在更新 DOM 时, 会先将需要更新的节点放入一个异步队列中, 等到下一个事件循环再执行实际的 DOM 更新。这意味着, 如果你在 Vue 的更新过程中直接操作了真实 DOM, 可能会覆盖 Vue 的更新, 导致视图不一致。
3. **破坏响应式系统** : Vue 的响应式系统依赖于数据的观察者。当你直接修改一个响应式对象时, Vue 可能无法检测到这种变化, 从而导致视图不更新。这可能会让你觉得操作真实 DOM 是一种解决方法, 但实际上, 这样做可能会破坏 Vue 的响应式系统, 使你的应用状态变得难以预测。
4. **难以维护** : 过度依赖直接操作 DOM 会使你的代码难以理解和维护。当 DOM 结构或样式发生变化时, 这些直接操作 DOM 的代码可能会变得无效或引发错误。

为了避免这些问题, 你可以考虑以下建议: 

- **尽量使用 Vue 的指令和 API**: Vue 提供了许多用于操作 DOM 的指令和 API, 如 v-if、v-for、v-show、v-model 等。这些指令和 API 在设计时已经考虑到了性能因素, 可以确保视图和数据的同步。
- **使用计算属性和侦听器** : 当需要基于现有数据计算新值时, 可以使用计算属性。当依赖的数据发生变化时, 计算属性会自动重新计算。同样, 侦听器可以用来观察数据的变化, 并在数据变化时执行特定的函数。
- **避免在循环或频繁触发的事件处理程序中直接操作 DOM** : 在循环中直接操作 DOM 会导致性能问题, 因为每次迭代都会触发 DOM 操作。同样, 在频繁触发的事件处理程序中直接操作 DOM 也会导致性能问题。在这些情况下, 考虑使用虚拟 DOM 或其他优化技术。
- **使用 Vue 的过渡和动画 API** : Vue 提供了过渡和动画 API, 可以帮助你以性能友好的方式实现动画效果。这些 API 利用了 CSS3 的过渡和动画特性, 而不是直接操作 DOM。

---

## 51.Vue中如何获取dom、操作dom、更新dom

在Vue中, 可以通过ref属性来获取DOM元素。首先需要为目标DOM元素添加ref属性, 然后使用this.$refs.xxx来访问该DOM元素。

示例代码如下所示: 

```vue showLineNumbers copy
<template>
  <div ref="myDiv">Hello Vue!</div>
</template>
 
<script>
export default {
  mounted() {
    // 获取DOM元素
    const myElement = this.$refs.myDiv;
    
    // 对DOM进行操作
    myElement.style.color = 'red';
  
    // 更新DOM内容
    myElement.innerText = 'Updated DOM content';
  }
}
</script>
```

---

## 52.vue中为什么用虚拟dom而不操作真实dom

不直接操作真实DOM, 因为很昂贵, 我们去操作这个JS对象, 就不会触发大量回流重绘操作, 再加上diff算法, 可以找到两次虚拟DOM之间改变的部分, 从而最小量的去一次性更新真实DOM, 而不是频繁操作DOM, 性能得到了大大的提升。

---

## 53.在Vue中, 子组件为何不可以修改父组件传递的Prop

Vue提倡单向数据流,即父级props的更新会流向子组件,但是反过来则不行。这是为了防止意外的改变父组件状态, 使得应用的数据流变得难以理解。如果破坏了单向数据流, 当应用复杂时, debug 的成本会非常高。

---

## 54.双向绑定和vuex是否冲突

双向绑定和Vuex并不直接冲突, 但在某些情况下可能会引起一些问题。

双向绑定是指视图(View)和模型(Model)之间的双向数据绑定, 当视图中的数据发生变化时, 模型会随之更新;反过来, 当模型中的数据发生变化时, 视图也会相应地更新。在Vue中, 通过`v-model`指令可以实现双向数据绑定。

Vuex是Vue的状态管理库, 用于集中管理应用程序的状态。它提供了一个单一的、可预测的状态树, 并通过mutation和action来修改和管理状态。Vuex的核心思想是通过单向数据流来管理状态, 即从状态树到视图的单向数据流。

在使用Vuex时, 可以将状态存储在Vuex的状态树中, 并通过getter获取状态, 通过mutation来修改状态。这种方式可以保持状态的一致性和可追踪性, 避免了多个组件直接修改共享状态的问题。

然而, 当双向绑定和Vuex同时使用时, 可能会引起一些问题。双向绑定可能导致视图直接修改了Vuex中的状态, 而绕过了Vuex的mutation, 这可能破坏了状态的可预测性和一致性。另外, 在大型应用中, 双向绑定可能导致状态的变更难以追踪和调试。

为了避免这些问题, 通常建议在使用Vuex时尽量避免直接在组件中使用双向绑定。相反, 通过使用Vuex的getter来获取状态, 在组件中使用单向数据流来更新视图。如果需要在组件中修改状态, 应该使用Vuex的mutation或action来进行, 以保持状态管理的一致性和可追踪性。

---

## 55.Vue的父组件和子组件生命周期钩子执行顺序是什么

**加载渲染过程**

`父beforeCreate` --> `父created` --> `父beforeMount` --> `子beforeCreate` --> `子created` --> `子beforeMount` -->` 子Mounted` --> `父Mounted`

**子组件更新过程**

`父beforeUpdate` --> `子beforeUpdate` --> `子updated` --> `父updated`

**父组件更新过程**

`父beforeUpdate` --> `父updated`

**销毁过程**

`父beforeDestory` --> `子beforeDestory` --> `子destoryed` --> `父destoryed`

---

## 56.第一次页面加载会触发哪几个钩子

第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子

---

## 57.请说出vue.cli项目中src目录每个文件夹和文件的用法?

- assets: 文件夹是放静态资源
- components: 是放组件
- router: 是定义路由相关的配置 
- app.vue: 是一个应用主组件
- main.js: 是入口文件

---

## 58.vue-loader是什么?使用它的用途有哪些?

- 解析.vue文件: vue-loader可以解析.vue文件中的模板、样式和脚本, 并将它们分离出来进行处理
- 支持单文件组件的开发方式: 通过vue-loader, 可以使用单文件组件的方式来开发Vue.js应用, 将模板、样式和脚本组织在一个文件中, 使代码更加清晰和易于维护
- 热重载: vue-loader支持热重载功能, 即在开发过程中对.vue文件的修改会立即反映在浏览器中, 无需手动刷新页面
- 预处理器支持: vue-loader支持各种预处理器, 如Sass、Less和Stylus, 可以在.vue文件中使用这些预处理器语言来编写样式

---

## 59.assets和static的区别

相同点: 资源在html中使用, 都是可以的。

不同点: 使用assets下面的资源, 在js中使用的话, 路径要经过webpack中file-loader编译, 路径不能直接写

---

## 你了解axios的原理吗?有看过它的源码吗?

TODO
