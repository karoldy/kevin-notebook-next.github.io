# Vue 面试题

## vue2

### MVVM框架的理解

**MVVM**是**Model-View-ViewModel**的简写。即【模型】-【视图】-【视图模型】

- 【模型】(Model)：指的是后端传递的数据
- 【视图】(View)：指的是所看到的页面
- 【视图模型】(ViewModel)：mvvm模式的核心，它是连接view和model的桥梁。

**视图模型有两个方向：**

一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是数据绑定。

二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM事件监听。

这两个方向都实现的，我们称之为数据的双向绑定。

**总结：**

在MVVM的框架下视图和模型是不能直接通信的。它们通过viewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的view和ViewModel可以互相通信。

>Vue就是基于MVVM实现的一套框架，在vue中，【模型】指的是JavaScript中的数据，如对象，数组等。【视图】指的是页面视图。【视图模型】指的是vue的实例化对象。

>Vue最独特的特性：响应式系统。vue是响应式的，也就是说当我们的数据变更时，vue会帮你更新所有网页中用到它的地方。关于这个响应式原理，官方已经讲得很清楚，[请参考](https://cn.vuejs.org/v2/guide/Reactivity.html)

---

### 2.如何理解Vue是一套渐进式的框架

渐进式是什么意思？

1. 如果你有一个现成的服务端应用，你可以将vue作为该应用的一部分嵌入其中，带来更加丰富的交互体验
2. 如果你希望将更多业务逻辑放到前端来实现，那么vue的核心库及其生态系统也可以满足你的各式需求(core+vuex+vue-router)。和其他前端框架一样，vue允许你将一个网页分割成可复用的组件，每个组件包含属于自己的Html、css。JavaScript用来渲染网页中相应的地方。
3. 如果我们构建一个大型的应用，在这一点上，我们可能需要将东西分割成各自的组件和文件，vue有一个命令行工具，使快速初始化一个真实的工程变得非常简单。我们可以用vue的单文件组件，它包含了各自的Html、Css、JavaScript以及带作用域的Css或者Scss。

以上三个例子，是一步步递进的，也就是说对Vue的使用可大可小，它都会有相应的方式整合到你的项目中。所以说它是一个渐进式的框架。

---

### 3.vue生命周期

**vue生命周期指的是**：vue实例从创建到销毁的过程 -- 开始创建、初始化数据、编译模板、挂载DOM->渲染、更新->渲染、卸载

**生命周期函数**

- `beforCreate`：实例初始化后 ，未有`data`、`event`、`watcher`

- `created`：实例创建完成，已有`data`,属性和方法的运算，watch/event的事件回调。未有`$el`

- `beforMount`：挂载开始前 相关的`render`函数首次被调用

- `mounted`：挂载完成，此时有`$el`

- `beforeUpdate`：数据更新时调用，虚拟DOM打补丁之前

- `updated`：虚拟DOM重新渲染和打补丁后调用

- `beforeDestroy`：实例销毁前

- `destroyed`：实例销毁后

- `activated`：keep-alive组件激活时

- `deactivated`：keep-alive组件停用时

- `errorCaptured(2.5.0+)`：捕获一个来自子孙组件的错误时被调用，此钩子有三个参数：错误对象、发送错误的组件实例、包含错误来源信息的字符串

---

### 4.Vue的两个核心

**1. 数据驱动，也叫双向数据绑定**

`Vue`数据观测原理在实现上，是利用了es5的 `Object.defiedProperty`和存储器属性: `getter`和`setter`(所以只兼容IE 9及以上版本)，主要核心是VM，也就是ViewModel，保证数据和视图的一致性

**2. 组件系统**

- 1、模板(template): 模板声明了数据和最终展现给用户的DOM之间的映射关系。
- 2、初始数据(data): 一个组件的初始数据状态，对于可复用的组件来说，这通常是私有的状态。
- 3、接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享
- 4、方法(methods)：对数据的改动操作一般都在组件的方法内进行
- 5、生命周期钩子函数：一个组件会触发多个生命周期钩子函数
- 6、私有资源(assets)：Vue当中将用户自定义的指令、过滤器、组件等统称为资源。一个组件可以生命自己的私有资源，私有资源只有该组件和他的子组件可以调用

---

### 5.Vue常用指令

`v-if`: 根据条件真假判断是否渲染元素，在切换时元素及他的数据绑定/组件被销毁并重建

`v-show`: 根据条件真假判断，切换元素的css中display的属性 none/block

`v-for`: 循环指令

`v-bind`: 动态绑定一个或多个特性，v-bind:name= ，简写 :name=

`v-on`: 监听执行元素的事件，比如点击事件 v-on:name,简写 @name

`v-model`: 实现表单输入和应用状态之间的双向绑定

`v-pre`: 跳跳过这个元素和它的子元素的编译过程。一些静态的内容不需要编辑加这个指令可以加快编辑

`v-once`: 只渲染元素和组件一次

`v-html`: 更新元素的innerHTML

`v-text`: 更新元素的textContent

---

### 6.v-if和v-show的区别

**共同点**

v-if和v-shoe都是可以动态显示/隐藏DOM元素

**不同点**

1. **编译过程**：v-if是真正的条件渲染，会确保在切换过程中条件模块内的 事件监听器和子组件适当的销毁和重建，而v-show的元素始终会被渲染并保留在DOM中，因为v-show只是简单切换元素css的display属性
2. **编译条件**：v-if是惰性的，如果在初始渲染时条件为假，则什么也不做，直到条件第一次为真时，才开始渲染条件快，而v-show不管初始条件是什么，元素都会被渲染，只是会根据条件设置不同的display属性
3. **性能消耗**：v-if有更高的切换消耗，v-show则有更高的初始渲染消耗
4. **应用场景**：v-if适合条件改变次数少的时候使用，v-show适合频繁切换条件的场景

---

### 7.vue常用修饰符

**v-on常用修饰符**

- `.stop` - 调用event.stopPropagation() 禁止事件冒泡
- `.prevent` - 调用event.preventDefault() 阻止事件默认行为
- `.capture` - 添加事件侦听器时使用capture模式（即内部元素触发的事件先在此处理，然后才交由内部元素进行处理）
- `.self` - 当事件是从侦听器绑定的元素本身触发时才触发回调
- `.{keycde|keyalias}` - 只有当事件是从特定按键触发时才触发的回调 如.enter
- `.native` - 监听组件根元素的原生事件
- `.once` - 只触发一次回调
- `.left` - 只当点击鼠标左键时触发(2.2.0)
- `.right`- 鼠标右键时触发
- `.middle` - 鼠标中键时触发
- `.passive` - 以 `{passive:true}` 模式添加侦听器 (2.3.0)

**v-bind常用修饰符**

- `.prop` - 被用于绑定DOM属性(property)
- `.camel` - 将kebab-case 特性名转为cameCase
- `.sync` - 语法糖，会拓展成一个更新父组件绑定值得v-on侦听器

**v-model常用指令**

- `.lazy` - 取代input监听change事件
- `.number` - 输入字符串转为数字
- `.trim` - 输入首尾空格过滤

---

### 8.v-on可以监听多个方法吗

可以

1. 使用`v-on="{ method1(), method2()}"`的方式，这种方式可以在同一个元素上绑定多个方法。
2. 另一种高级用法是将所有需要传递给子组件的事件函数存储在一个数组中，然后在子组件中使用`v-on="$listener"`的方式来注册这些方法。

---

### 9.vue中key的作用？为什么不推介使用index作为key？

**key 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。**

如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。

使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素

1. key的作用主要是为了高效的更新虚拟DOM（使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素）

2. 当以数组的下标index作为index值时，其中一个元素（如增删改查）发生了变化就有可能导致所有元素的key值发生变化

---

### 10.vue事件中如何使用event对象

vue传递事件对象 `$event` 

有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法

例子：

```vue showLineNumbers copy
<template>
  <a href="javascript:;" data-id="1" @click="clickEvent($event)">event</a>
</template>

<script>
export default {
  methods: {
    clickEvent(event){
      // 获取data-id
      console.log(event.target.dataset.id)
      // 阻止事件冒泡
      event.stopPropagation()
    }
  }
}
</script>
```

### 11.vue中$nextTick的使用

**nextTick的定义**

在DOM更新完后在执行回调函数，简单理解:就是当数据更新完，DOM渲染完毕后，在执行回调函数

**nextTick只需了解这么多**

1. 修改data数据后，数据不是实时更新的。
2. 当你需要在数据更新dom后执行某个操作，该操作需要放在nextTick中。

>当你设置 vm.someData = ‘new value’，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。如果你想基于更新后的 DOM 状态来做点什么，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。例如：

```vue showLineNumbers copy
<!-- 这页面显示一个输入框或者是按钮，最开始是展示一个按钮，当点击按钮后，则显示输入框 -->
<!-- 当输入框失去焦点后，则显示按钮-->
<!-- 需求: 当输入框展示的时候，自动获取焦点，获取焦点使用的是focus()方法-->
<!-- 若是在按钮点击后，直接使用focus()方法获取焦点，则会失败，因为DOM还没渲染到页面-->
<!-- 拿不到输入框的ref，所以需要用到了nextTick()方法-->
<template>
  <div>
    <input type="text" v-if="flag" ref="inputRef" @blur="showButton">
    <button v-else @click="showInput">展示输入框</button>
  </div> 
</template>
<script>
  export default{
    data(){
      return {
        flag: false
      }
    },
    methods: {
      showInput(){
        this.flag = true;
        this.$nextTick(() => {
          this.$refs.inputRef.focus();
        })
      },
      showButton(){
        this.flag = false;
      }
    }
  }
</script>
```

**使用场景**
1. 在生命周期created()中进行的dom操作一定要放到nextTick()的回调函数中。
2. 在数据变化后要执行某个操作，而这个操作需要使用随数据变化而变化的dom结构时，这个操作都应该放进nextTick()的回调函数中。

**原因**

原因是，Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。
当你设置 vm.someData = 'new value'，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。

---

### 12.异步更新队列

Vue在观察到数据变化时并不是直接更新DOM，而是开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。
所以同一个watcher被多次触发，只会添加到队列一次，因此可以去除重复数据可以避免不必要的计算和DOM操作

Vue在内部对异步队列尝试使用原生的Promise.then 、 MutationObserver和setImmediate,
如果以上都不支持，则采用setTimeout(fn,0)代替

---

### 13.data为什么是个函数

JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。而在Vue中，我们更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当我们每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。

这个是因为js本身的特性（原型链）带来的，和vue本身设计无关

---

### 14.v-for和v-if的优先级

**vue2.x 在同一个节点上，v-for的优先级比v-if优先级高**

**vue3.x的优先级则相反，v-if优先级比v-for高**

**注意事项**

永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）

---

### 15.vue组件通信方式

1. 父传子
2. 子传父
3. eventbus
4. ref/$refs
5. $parent/$children
6. $attrs/$listeners
7. 依赖注入(provide/inject)

[参考](/vue/vue2/vue_1)

---

### 16.keep-alive组件

**keep-alive组件的作用**

keep-alive 主要用于保留组件状态和避免重新渲染，常见就是列表页进入详情页，返回列表页时可以从缓存中快速渲染，而不是重新渲染

**keep-alive的属性**

- include: 字符串或正则表达式，只有匹配的组件会被缓存
- exclude: 字符串或正则表达式，任何匹配的组件都不会被缓存

>exclude的优先级大于includes

**keep-alive的生命周期**

- activated: 被 keep-alive 缓存的组件激活时调用。
- deactivated: 被 keep-alive 缓存的组件失活时调用。

>vue性能优化的一种方式

---

### 17.Vue更新数组时触发视图更新的方法

**Vue包含一组观察数组的编译方法，所以他们将会触发视图更新，方法如下：**

- `push()` - 数组添加元素
- `pop()` - 移除最后一个元素
- `shift()` - 删除第一个元素，并返回该元素
- `unshift()` - 在数组开头添加元素，并返回新的长度
- `splice()` - 向数组添加/删除项目，并返回删除的项目
- `sort()` - 数组排序
- `reverse()` - 调到数组元素的顺序

---

### 18.data更新但视图没更新的原因

**vue不能检测以下变动的数组**

1. 利用索引直接设置一个项：vm.items[index] = value
2. 修改数组长度时：vm.items.length = newLength

**Vue不能检测对象属性的新增和删除**

因为vue会在初始化实例时对属性执行getter和setter转化，所以属性必须在data对象中存在才能让vue将他转为响应式的

```js showLineNumbers copy
var vm = new Vue()
data = { a: 1}
vm.a = 2 // 这是响应式的
vm.b = 3 // 这不是响应的
```

可以使用Vue.set触发视图更新，如果是数组长度修改，则可以用vm.list.splice(newLength)

---

### 19.Vue等单页面应用的优缺点

 **单页面应用（SPA）**

它是指只有一个主页面的应用，浏览器y一开始加载所有的html ,js 以及css，这些所用页面的内容都包含在这个主页面中，但是在手写中，他们还是分开来书写的，在交互的时候，由路由程序动态载入，单页面的页面跳转，是整页刷新的。

组成：是由一个外壳和多个页面片段组成 

**单页面的优点：**

1. 用户的体验好，快，内容的改变不需要重新加载整个页面，由于这点，SPA它对服务器的压力小
2. 前后端分离
3. 页面效果比较炫酷

**单页面的缺点：**

1. 不利于seo优化
2. 导航不可用
3. 初次加载时耗时多
4. 页面的复杂程度提高了很多

---

### 20.计算属性的缓存和方法调用的有什么区别

- 计算属性必须返回结果
- 计算属性是基于它的依赖缓存的，一个计算属性所依赖的数据发生变化时，它才会重新取值
- 使用计算属性还是methods，取决于是否需要缓存，当遍历大数据和做大量计算时，应当使用计算属性
- 计算属性是根据依赖自动执行的，methods需要事件调用

---

### 21.vue自定义指令

**如何使用自定义指令**

```js showLineNumbers copy
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus',{
  // 当被绑定的元素插入到 DOM 中时……  
  inserted: function (el) { 
    // 聚焦元素 
    el.focus()
  }
})
```

```html showLineNumbers copy
<input v-focus />
```

**自定义指令的钩子函数**

- `bind` - 只调用一次，指令第一次绑定到元素时调用
- `inserted` - 被绑定元素插入父节点时调用
- `update` - 所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前
- `componentUpdated` - 指令所在组件的VNode及其子VNode全部更新后调用
- `unbind` - 只调用一次，指令与元素解绑时调用

---

### 22.computed和watch区别

**1.computed的特点**

(1) 支持缓存，默认走缓存，多次调用，只会执行一次计算。只有依赖的数据发生改变，才会重新计算；

(2) 不支持异步，如果有异步操作，无法监听；

(3) 属性值为函数，默认使用get方法，当数据改变时，会调用set方法；

(4) 主要解决模版中放入过多的逻辑导致不好维护的问题；

**2. watch的特点**

(1) 不支持缓存，只要数据发生变化，就会触发相应的操作；

(2) 支持异步监听；

(3) 接收两个参数，第一个是最新值，第二个是之前的值；

(4) 还有两个其他参数：deep：默认false，深度监听，immediate：默认false，初始化时执行回调函数；

**3.总结**

(1) computed计算属性，他依赖其他属性值，有缓存，只有依赖的值发生变化才会去重新计算，但是不能异步；

(2) watch监听，监听数据的变化，无缓存，数据变化就会执行回调，可以异步；

[计算属性computed和watch监视的使用和区别](/vue/vue2/vue_2)

---

### 23.Object.defineProperty 和 proxy的区别

1. `Object.defineProperty`只能劫持对象的属性，需要遍历对象的每个属性，如果属性值也是对象，则需要深度遍历，而proxy是直接代理对象，不需要遍历操作
2. `Object.defineProperty`对新增属性需要手动进行observe，因为defineproperty劫持的是对象的属性，所以新增属性时，需要重新遍历对象，再对新增属性再使用defineproperty进行劫持。而proxy可以直接监听对象属性的添加

也是因为这个原因，vue2.0在给data中的数组或对象新增属性时，需要用vm.$set来保证新增属性的响应

**简单的说**

definedProperty的缺陷

- 不能监听数组变化
- 必须遍历对象的每个属性
- 必须深层遍历嵌套对象

**proxy对比definedProperty的优点**

- proxy监听的是整个对象而不是对象的某个属性
- proxy可以监听数组的变化
- proxy结果返回一个新的对象，可以直接操作新对象，而不是像definedproperty遍历属性进行修改
- proxy相对性能更好
- proxy对浏览器的兼容性不够

---

### 24.vue diff算法

**diff算法的时间复杂度**

两个树的完全的diff算法是一个时间复杂度为 O(n3)，Vue进行了优化，转为了O(n)(只比较同级不考虑跨级问题)。因为在前端操作DOM的时候，不会把当前元素作为上一级或者下一级元素，很少会跨越层级地移动DOM元素，常见都是同级比较，所以vue只会对同一层级的元素进行比较

**diff算法原理和过程**

在数据发生变化时，Vue是先根据真实DOM生成一颗virtual DOM,当virtual DOM某个节点的数据改变后会生成一个新的VNode，然后新的Vnode和旧的Vnode作对比，发现不一样的地方就直接修改在真实的DOM上，实现更新节点

**流程简述**

1. 先去同级比较，然后再去比较子节点
2. 先去判断一方有子节点一方没有子节点的情况
3. 比较都有子节点的情况
4. 递归比较子节点

---

### 25.vue slot插槽

**基本用法**

在Vue中，插槽被用于在组件中定义可变的部分。组件可以将其内部的内容暴露出去，允许父级组件在使用该组件时传入自定义内容。这种传递的内容可以是任何类型的Vue实例，包括文字、HTML标签、其他组件等。

插槽的基本用法是在子组件中定义`<slot></slot>`元素。这个元素将作为一个占位符，用于接收父级组件传递过来的内容。具名插槽： 具名插槽允许你为组件的不同部分提供不同的内容。在组件模板中，你可以通过`<slot>`元素的name属性来定义具名插槽。例如： 

```vue showLineNumbers copy
// 子组件 ChildComponent.vue
<template>
  <div>
    <h1>子组件</h1>
    <slot></slot>
  </div>
</template>
```

```vue showLineNumbers copy
// 父组件 ParentComponent.vue
<template>
  <div>
    <h1>父组件</h1>
    <ChildComponent>
      <p>这是插槽的内容</p>
    </ChildComponent>
  </div>
</template>
```

在上面的例子中，我们在子组件中定义了一个插槽，然后在父组件中使用`<ChildComponent>`标签，并在标签内部放置了一个`<p>`标签作为插槽的内容。当父组件被渲染时，插槽的内容将被替换为实际传入的内容。

**具名插槽**

在上面的例子中，我们使用的是默认插槽，也就是没有给插槽命名。在某些情况下，我们可能需要定义多个插槽，并且通过名称来区分它们。这就是具名插槽的用法。

具名插槽可以通过在`<slot>`元素上添加`name`属性来定义。下面是一个具名插槽的例子：

```vue showLineNumbers copy
// 子组件 ChildComponent.vue
<template>
  <div>
    <h1>子组件</h1>
    <slot name="header"></slot>
    <slot></slot>
    <slot name="footer"></slot>
  </div>
</template>
```

```vue showLineNumbers copy
// 父组件 ParentComponent.vue
<template>
  <div>
    <h1>父组件</h1>
    <ChildComponent>
      <template v-slot:header>
        <h2>这是头部插槽的内容</h2>
      </template>
      <p>这是默认插槽的内容</p>
      <template v-slot:footer>
        <footer>这是尾部插槽的内容</footer>
      </template>
    </ChildComponent>
  </div>
</template>
```

在上面的例子中，我们在子组件中定义了三个插槽，并分别给它们起了名称。在父组件中，我们使用`v-slot`指令来指定不同的插槽，并在`<template>`中放置插槽的内容。

**作用域插槽**

除了基本的插槽功能，Vue还提供了一种更强大的插槽功能，即作用域插槽。作用域插槽允许子组件向父组件传递数据，实现更为灵活的组件交互。

作用域插槽使用`<slot>`元素中的属性来传递数据。下面是一个作用域插槽的例子：

```vue showLineNumbers copy
// 子组件 ChildComponent.vue
<template>
  <div>
    <h1>子组件</h1>
    <slot v-bind:user="user"></slot>
  </div>
</template>
 
<script>
export default {
  data() {
    return {
      user: {
        name: 'John Doe',
        age: 26
      }
    }
  }
}
</script>
```

```vue showLineNumbers copy
// 父组件 ParentComponent.vue
<template>
  <div>
    <h1>父组件</h1>
    <ChildComponent>
      <template v-slot:default="slotProps">
        <h2>用户信息</h2>
        <p>{{ slotProps.user.name }}</p>
        <p>{{ slotProps.user.age }}</p>
      </template>
    </ChildComponent>
  </div>
</template>
```

在上面的例子中，我们在子组件中定义了一个插槽，并使用`v-bind`指令将`user`对象传递给插槽。在父组件中，我们使用带有`slotProps`名称的属性来接收子组件传递的数据，并在插槽中使用。

**插槽的高级用法**

除了基本和具名插槽以及作用域插槽之外，Vue的插槽还有一些高级用法，如动态插槽、作用域插槽的默认值以及插槽的替代内容。

动态插槽允许在运行时动态选择要使用的插槽。通过使用`v-slot`的值作为动态属性值，可以根据需要选择不同的插槽。下面是一个动态插槽的例子：

```vue showLineNumbers copy
// 子组件 ChildComponent.vue
<template>
  <div>
    <h1>子组件</h1>
    <slot :name="slotName"></slot>
  </div>
</template>
 
<script>
export default {
  data() {
    return {
      slotName: 'header'
    }
  }
}
</script>
```

```vue showLineNumbers copy
// 父组件 ParentComponent.vue
<template>
  <div>
    <h1>父组件</h1>
    <ChildComponent>
      <template v-slot:[slotName]>
        <h2>{{ slotName }}插槽的内容</h2>
      </template>
    </ChildComponent>
    <button @click="changeSlotName">切换插槽</button>
  </div>
</template>
 
<script>
export default {
  data() {
    return {
      slotName: 'header'
    }
  },
  methods: {
    changeSlotName() {
      this.slotName = this.slotName === 'header' ? 'footer' : 'header'
    }
  }
}
</script>
```

在上面的例子中，我们使用了`v-slot`的值作为动态属性值，根据当前的`slotName`选择不同的插槽。点击按钮时，`slotName`的值会发生变化，从而切换到不同的插槽。

**注意事项：**

- 如果未提供任何内容来填充插槽，则插槽内的内容将被视为默认内容，并在组件模板中显示。
- 你也可以使用特殊的语法糖#来定义插槽，例如`<template #header>`等价于`<template v-slot:header>`。

插槽是 Vue.js 的一个非常强大和灵活的特性，它使得组件的结构更加可配置和可复用。通过合理使用插槽，你可以轻松地扩展组件的功能并满足各种不同的使用场景。

---

### 26.vue props如何自定义验证

```js showLineNumbers copy
export default {
  props: {
    num: {
      default: 1,
      validator: function(value) {
        // 返回false则验证不通过，报错 
        return value <= 2;
      }  
    }
  }
}
```

---

### 27.如何让CSS只在当前组件中起作用

Vue可以通过使用scoped属性来限制样式仅应用于特定的组件。

在单文件组件（.vue）中，将style标签添加scoped属性，示例如下所示：

```vue showLineNumbers copy
<template>
  <!-- 模板内容 -->
</template>
 
<script>
export default {
  // 组件逻辑
}
</script>
 
<style scoped>
/* CSS样式 */
</style>
```

这样设置后，该组件的CSS样式就会被局部化，不会影响其他组件或全局样式。

---

### 28.相同路由组件如何重新渲染

Vue默认不会对相同的路由的切换做重新渲染

如果需要重新渲染，可以添加key

```vue showLineNumbers copy
<template>
  <router-view :key="$route.path"></router-view>
</tempalte>
```

---

### 29.如何获取data某个数值的初始值

data的属性改变后，可以通过`this.$options.data().x` 获取初始值

---

### 30.created和mounted的区别

created和mounted都是Vue生命周期钩子函数，但它们的执行时机不同。

created是在实例创建完成后立即执行的钩子函数，此时组件的DOM节点还未生成，数据也还未渲染到页面上。

mounted是在组件挂载到页面上后执行的钩子函数，此时组件的DOM节点已经生成，数据也已经渲染到页面上。

因此，如果需要在组件创建时进行一些数据初始化的操作，可以使用created钩子函数；如果需要在组件挂载到页面上后进行一些DOM操作或与后端交互的操作，可以使用mounted钩子函数。

---

### 31.v-model语法糖是怎么实现的

`v-model`是`value` + `input`的语法糖，是`v-band`和`v-on`的简洁写法。`v-model`就实现了双向数据绑定，实际上它就是通过Vue提供的事件机制。即在子组件通过`$emit()`触发一个事件，在父组件使用`v-model`即可

---

### 32.vue eventbus(事件总线)具体是怎么实现的

`EventBus` 又称为事件总线。在Vue中可以使用 `EventBus` 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎，就会造成难以维护的"灾难"，因此才需要更完善的`Vuex`作为状态管理中心，将通知的概念上升到共享状态层次。

[Vue事件总线(EventBus)使用详细介绍](/vue/vue2/vue_3)

---

### 33.说说vue操作真实dom性能瓶颈

1. **DOM 操作的代价** ：直接操作 DOM 是昂贵的操作，因为它涉及到浏览器渲染引擎的重新计算、布局和绘制。Vue 通过虚拟 DOM 尽量减少了对真实 DOM 的操作，但在某些情况下，如使用 ref 或 $el 直接访问 DOM 元素时，我们可能会不自觉地触发大量的 DOM 操作，从而影响性能。
2. **异步更新队列** ：Vue 在更新 DOM 时，会先将需要更新的节点放入一个异步队列中，等到下一个事件循环再执行实际的 DOM 更新。这意味着，如果你在 Vue 的更新过程中直接操作了真实 DOM，可能会覆盖 Vue 的更新，导致视图不一致。
3. **破坏响应式系统** ：Vue 的响应式系统依赖于数据的观察者。当你直接修改一个响应式对象时，Vue 可能无法检测到这种变化，从而导致视图不更新。这可能会让你觉得操作真实 DOM 是一种解决方法，但实际上，这样做可能会破坏 Vue 的响应式系统，使你的应用状态变得难以预测。
4. **难以维护** ：过度依赖直接操作 DOM 会使你的代码难以理解和维护。当 DOM 结构或样式发生变化时，这些直接操作 DOM 的代码可能会变得无效或引发错误。

为了避免这些问题，你可以考虑以下建议：

- **尽量使用 Vue 的指令和 API**：Vue 提供了许多用于操作 DOM 的指令和 API，如 v-if、v-for、v-show、v-model 等。这些指令和 API 在设计时已经考虑到了性能因素，可以确保视图和数据的同步。
- **使用计算属性和侦听器** ：当需要基于现有数据计算新值时，可以使用计算属性。当依赖的数据发生变化时，计算属性会自动重新计算。同样，侦听器可以用来观察数据的变化，并在数据变化时执行特定的函数。
- **避免在循环或频繁触发的事件处理程序中直接操作 DOM** ：在循环中直接操作 DOM 会导致性能问题，因为每次迭代都会触发 DOM 操作。同样，在频繁触发的事件处理程序中直接操作 DOM 也会导致性能问题。在这些情况下，考虑使用虚拟 DOM 或其他优化技术。
- **使用 Vue 的过渡和动画 API** ：Vue 提供了过渡和动画 API，可以帮助你以性能友好的方式实现动画效果。这些 API 利用了 CSS3 的过渡和动画特性，而不是直接操作 DOM。

---

### 34.Vue中如何获取dom、操作dom、更新dom

在Vue中，可以通过ref属性来获取DOM元素。首先需要为目标DOM元素添加ref属性，然后使用this.$refs.xxx来访问该DOM元素。

示例代码如下所示：

```vue showLineNumbers copy
<template>
  <div ref="myDiv">Hello Vue!</div>
</template>
 
<script>
export default {
  mounted() {
    // 获取DOM元素
    const myElement = this.$refs.myDiv;
    
    // 对DOM进行操作
    myElement.style.color = 'red';
  
    // 更新DOM内容
    myElement.innerText = 'Updated DOM content';
  }
}
</script>
```

---

### 35.vue中为什么用虚拟dom而不操作真实dom

不直接操作真实DOM，因为很昂贵，我们去操作这个JS对象，就不会触发大量回流重绘操作，再加上diff算法，可以找到两次虚拟DOM之间改变的部分，从而最小量的去一次性更新真实DOM，而不是频繁操作DOM，性能得到了大大的提升。

---

### 36.说说vue中的虚拟dom和diff算法

在Vue（以及许多其他前端框架和库，如React）中，虚拟DOM（Virtual DOM）和diff算法是两个核心概念，它们共同提高了应用程序的性能和响应速度。

**虚拟DOM（Virtual DOM）**

虚拟DOM是一个编程概念，其中一个“虚拟的”节点树被用作中间层，将真实DOM树与底层数据保持同步。每当数据发生变化时，Vue会创建一个新的虚拟节点树，并将其与旧的虚拟节点树进行比较，而不是直接修改真实的DOM树。这种方式的优点在于，操作虚拟DOM（在内存中进行）比在DOM上执行DOM操作要快得多，因为DOM操作通常涉及到昂贵的重排和重绘。

**Diff算法**

Diff算法（也称为Reconciliation或Reconciliation Algorithm）是Vue（以及React）用来比较两棵虚拟DOM树并确定如何有效地将一棵树转换为另一棵树的算法。这个算法的核心思想是比较两棵树中的节点，并确定最小的改变集，以便应用这些改变到实际的DOM上。

Vue的Diff算法有以下关键特点：

1. **深度优先遍历** ：Vue会深度优先遍历两棵树，对树中的每个节点进行比较。
2. **Key值** ：Vue使用每个节点的key属性来确定节点是否改变、被添加或被删除。如果没有提供key值，Vue会使用一个基于索引的key，这可能在列表操作中导致性能问题。
3. **节点比较** ：如果两个节点是同一类型（即，它们都是元素节点或都是组件节点），Vue会进一步比较它们的属性和子节点。
4. **最小化DOM操作** ：Vue会尝试最小化必要的DOM操作。例如，如果两个节点具有相同的属性和子节点，Vue会重用现有的DOM节点，而不是创建一个新的。

---

### 37.动态给vue的data添加一个新的属性时会发生什么？怎样解决？

动态给vue的data添加一个新的属性时，这个新属性不会被响应式的监听和更新。也就是说，当你修改这个属性时，视图不会发生变化。

解决方法有两种：

**1.使用Vue.set()或this.$set()方法**

可以使用Vue.set(obj, key, value)或this.$set(obj, key, value)方法来向响应式对象中添加一个属性，这样添加的属性就会被监听和更新，可以触发视图的重新渲染。

```js showLineNumbers copy
Vue.set(this.$data, 'newAttribute', 'new value');
// 或者
this.$set(this.$data, 'newAttribute', 'new value');
```

**2.在data中声明属性，并赋予初始值**

另外一种方法是在data中声明所有可能要用到的属性，即使初值为null或undefined。这样，在后续操作中只需要修改这个属性的值即可，因为它已经被监测到了。

```js showLineNumbers copy
export default {
  data: {
    message: 'Hello Vue!',
    newAttribute: null
  },
  methods: {
    updateNewAttribute () {
      this.newAttribute = 'new value';
    }
  }
}
```

---

### 38.vue的mixin的理解，有什么应用场景?

**mixin是什么**

Mixin是面向对象程序设计语言中的类，提供了方法的实现。其他类可以访问mixin类的方法而不必成为其子类

Mixin类通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用又避免了多继承的复杂

**Vue中的mixin**

官方定义

>mixin（混入），提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。

本质其实就是一个js对象，它可以包含我们组件中任意功能选项，如data、components、methods、created、computed等等

我们只要将共用的功能以对象的方式传入 mixins选项中，当组件使用 mixins对象时所有mixins对象的选项都将被混入该组件本身的选项中来

在Vue中我们可以**局部混入**跟**全局混入**

**局部混入**

定义一个mixin对象，有组件options的data、methods属性

```js showLineNumbers copy
var myMixin = {
  created: function () {
    this.hello()
  },
  methods: {
    hello: function () {
      console.log('hello from mixin!')
    }
  }
}
```

组件通过mixins属性调用mixin对象

```js showLineNumbers copy
Vue.component('componentA',{
  mixins: [myMixin]
})
```

该组件在使用的时候，混合了mixin里面的方法，在自动执行create生命钩子，执行hello方法

**全局混入**

通过Vue.mixin()进行全局的混入

```js
Vue.mixin({
  created: function () {
    console.log("全局混入")
  }
})
```

使用全局混入需要特别注意，因为它会影响到每一个组件实例（包括第三方组件）

>PS：全局混入常用于插件的编写

**注意事项：**

当组件存在与mixin对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖mixin的选项

但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行mixin的钩子，再执行组件的钩子

**使用场景**

在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立

这时，可以通过Vue的mixin功能将相同或者相似的代码提出来

举个例子

定义一个modal弹窗组件，内部通过isShowing来控制显示

```js showLineNumbers copy
const Modal = {
  template: '#modal',
  data() {
    return {
      isShowing: false
    }
  },
  methods: {
    toggleShow() {
      this.isShowing = !this.isShowing;
    }
  }
}
```

定义一个tooltip提示框，内部通过isShowing来控制显示

```js showLineNumbers copy
const Tooltip = {
  template: '#tooltip',
  data() {
    return {
      isShowing: false
    }
  },
  methods: {
    toggleShow() {
      this.isShowing = !this.isShowing;
    }
  }
}
```

通过观察上面两个组件，发现两者的逻辑是相同，代码控制显示也是相同的，这时候mixin就派上用场了

首先抽出共同代码，编写一个mixin

```js showLineNumbers copy
const toggle = {
  data() {
    return {
      isShowing: false
    }
  },
  methods: {
    toggleShow() {
      this.isShowing = !this.isShowing;
    }
  }
}
```

两个组件在使用上，只需要引入mixin

```js showLineNumbers copy
const Modal = {
  template: '#modal',
  mixins: [toggle]
};
 
const Tooltip = {
  template: '#tooltip',
  mixins: [toggle]
}
```

通过上面小小的例子，让我们知道了Mixin对于封装一些可复用的功能如此有趣、方便、实用

[参考](https://blog.csdn.net/weixin_44475093/article/details/111189453)

---

### 39.Vue中的过滤器了解吗?过滤器的应用场景有哪些?

**过滤器是什么**

过滤器（filter）是输送介质管道上不可缺少的一种装置

大白话，就是把一些不必要的东西过滤掉

过滤器实质不改变原始数据，只是对数据进行加工处理后返回过滤后的数据再进行调用处理，我们也可以理解其为一个纯函数

Vue 允许你自定义过滤器，可被用于一些常见的文本格式化

>ps: Vue3中已废弃filter

**如何用**

vue中的过滤器可以用在两个地方：双花括号插值和 v-bind 表达式，过滤器应该被添加在 JavaScript表达式的尾部，由“管道”符号指示：

```html showLineNumbers copy
<!-- 在双花括号中 -->
{{ message | capitalize }}

<!-- 在 `v-bind` 中 -->
<div v-bind:id="rawId | formatId"></div>
```

**定义filter**

在组件的选项中定义本地的过滤器

```js showLineNumbers copy
export default {
  filters: {
    capitalize: function (value) {
      if (!value) return ''
      value = value.toString()
      return value.charAt(0).toUpperCase() + value.slice(1)
    }
  }
}
```

定义全局过滤器：

```js showLineNumbers copy
Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})
​
new Vue({
  // ...
})
```

>注意：当全局过滤器和局部过滤器重名时，会采用局部过滤器

过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，capitalize 过滤器函数将会收到 message 的值作为第一个参数

过滤器可以串联：

``` showLineNumbers copy
{{ message | filterA | filterB }}
```

在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。

过滤器是 JavaScript函数，因此可以接收参数：

```js showLineNumbers copy
{{ message | filterA('arg1', arg2) }}
```

这里，filterA 被定义为接收三个参数的过滤器函数。

其中 message 的值作为第一个参数，普通字符串 'arg1' 作为第二个参数，表达式 arg2 的值作为第三个参数

举个例子：

```vue showLineNumbers copy
<div id="app">
  <p>{{ msg | msgFormat('疯狂','--')}}</p>
</div>

<script>
  // 定义一个 Vue 全局的过滤器，名字叫做  msgFormat
  Vue.filter('msgFormat', function(msg, arg, arg2) {
    // 字符串的  replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则
    return msg.replace(/单纯/g, arg+arg2)
  })
</script>
```

**小结：**

- 部过滤器优先于全局过滤器被调用
- 一个表达式可以使用多个过滤器。过滤器之间需要用管道符“|”隔开。其执行顺序从左往右

**应用场景**

平时开发中，需要用到过滤器的地方有很多，比如单位转换、数字打点、文本格式化、时间格式化之类的等

比如我们要实现将30000 => 30,000，这时候我们就需要使用过滤器

```js showLineNumbers copy
Vue.filter('toThousandFilter', function (value) {
  if (!value) return ''
  value = value.toString()
  return .replace(str.indexOf('.') > -1 ? /(\d)(?=(\d{3})+\.)/g : /(\d)(?=(?:\d{3})+$)/g, '$1,')
})
```

---

### 40.是怎么处理vue项目中的错误的?

[参考](https://blog.csdn.net/KlausLily/article/details/124185829)

---

### 41.vue要做权限管理该怎么做?

**路由层面控制**

在路由层面进行控制，可以在路由的元数据 meta 中设置用户权限，然后可以在路由守卫函数中进行校验。如果当前用户的权限符合该路由的要求，则策略继续进行，否则将导航到其他页面。

```js showLineNumbers copy
const routes = [
  {
    path: '/home',
    name: 'home',
    component: Home,
    meta: {
      requireAuth: true, // 需要用户权限
      roles: ['admin', 'guest'] // 受访问限制的角色
    }
  },
  {
    path: '/login',
    name: 'login',
    component: Login
  }
]

// 创建路由实例
const router = new VueRouter({
  routes
});

// 添加路由前置守卫
router.beforeEach((to, from, next) => {
  // 判断该路由是否需要登录权限
  if (to.meta.requireAuth) {
    // 如果需要，则校验用户是否已经登录
    if (Vue.auth.loggedIn()) {
      // 判断当前用户是否有访问该路由的权限
      if (to.meta.roles.indexOf(Vue.auth.getUserRole()) !== -1) {
        // 用户有访问权限，直接进入页面
        next()
      } else {
        // 跳转其他页面
        next('/denied')
      }
    } else {
      // 如果用户未登录，则跳转登录页面
      next('/login')
    }
  } else {
    // 如果不需要登录权限，直接进入页面
    next()
  }
});
```

在上面的代码中，路由的元数据 meta 中设置了 requireAuth 和 roles 两个属性，requireAuth 表示该路由需要用户登录才能访问，roles 表示受访问限制的角色。可以在 beforeEach 路由守卫函数中校验用户权限，如果用户有访问该路由的权限，则进入页面，否则跳转到其他页面。这样，就可以在路由层面进行权限控制了。

**组件层面控制**

在组件层面进行控制，可以利用 Vue 的指令来控制组件的显示和隐藏。例如，可以为每个组件设置一个权限属性，然后在指令中判断当前用户是否有访问该组件的权限，如果有，则显示组件，否则隐藏组件。

下面是一个组件示例：

```vue showLineNumbers copy
<template>
  <div v-if="allow">
    This is a component that requires authentication
  </div>
  <div v-else>
    You are not authorized to view this component
  </div>
</tempalte>
<script>
export default {
  data() {
    return {
      allow: false
    }
  },
  mounted() {
    // 获取当前用户权限，并根据权限设置组件的显示和隐藏
    if (Vue.auth.getCurrentUserRole()) === 'admin' {
      this.allow = true
    }
  }
}
</script>
```

在上面的代码中，利用 v-if 指令来判断当前用户是否有访问该组件的权限，并根据权限设置组件的显示和隐藏。这样，就可以在组件层面进行权限控制了。

---

### 42.vue项目本地开发完成后部署到服务器后报404是什么原因呢?

**1. 路径问题**

在开发Vue项目时，我们通常使用相对路径引用资源文件（如CSS、JS、图片等），但是在将项目部署到服务器时，相对路径可能会发生变化，导致无法找到相应的资源。此时可以通过使用绝对路径来解决这个问题，或者确保部署路径与相对路径一致。

**2. 服务器配置问题**

有时候，404错误也可能是由于服务器配置问题导致的。比如，服务器没有安装相关的依赖项或者配置不正确等。如果出现这种情况，需要检查服务器的配置是否正确，并进行相应的修复。

**3. 编译问题**

在开发Vue项目时，我们通常使用Webpack等工具对代码进行编译和打包。如果编译出现问题，可能会导致部署后的项目无法正常访问。此时可以检查编译是否成功以及是否存在语法错误等。

**4. 访问权限问题**

如果部署的服务器存在访问权限限制，可能会导致某些资源无法正常访问。此时可以检查访问权限设置是否正确，并根据需要进行相应的修改。

---

### 43.在Vue中，子组件为何不可以修改父组件传递的Prop

Vue提倡单向数据流,即父级props的更新会流向子组件,但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。

---

### 44.双向绑定和vuex是否冲突

双向绑定和Vuex并不直接冲突，但在某些情况下可能会引起一些问题。

双向绑定是指视图（View）和模型（Model）之间的双向数据绑定，当视图中的数据发生变化时，模型会随之更新；反过来，当模型中的数据发生变化时，视图也会相应地更新。在Vue中，通过`v-model`指令可以实现双向数据绑定。

Vuex是Vue的状态管理库，用于集中管理应用程序的状态。它提供了一个单一的、可预测的状态树，并通过mutation和action来修改和管理状态。Vuex的核心思想是通过单向数据流来管理状态，即从状态树到视图的单向数据流。

在使用Vuex时，可以将状态存储在Vuex的状态树中，并通过getter获取状态，通过mutation来修改状态。这种方式可以保持状态的一致性和可追踪性，避免了多个组件直接修改共享状态的问题。

然而，当双向绑定和Vuex同时使用时，可能会引起一些问题。双向绑定可能导致视图直接修改了Vuex中的状态，而绕过了Vuex的mutation，这可能破坏了状态的可预测性和一致性。另外，在大型应用中，双向绑定可能导致状态的变更难以追踪和调试。

为了避免这些问题，通常建议在使用Vuex时尽量避免直接在组件中使用双向绑定。相反，通过使用Vuex的getter来获取状态，在组件中使用单向数据流来更新视图。如果需要在组件中修改状态，应该使用Vuex的mutation或action来进行，以保持状态管理的一致性和可追踪性。

---

### 45.Vue的父组件和子组件生命周期钩子执行顺序是什么

**加载渲染过程**

父beforeCreate --> 父created --> 父beforeMount --> 子beforeCreate --> 子created --> 子beforeMount --> 子Mounted --> 父Mounted

**子组件更新过程**

父beforeUpdate --> 子beforeUpdate --> 子updated --> 父updated

**父组件更新过程**

父beforeUpdate --> 父updated

**销毁过程**

父beforeDestory --> 子beforeDestory --> 子destoryed --> 父destoryed

---

### 46.vue在v-for时给每项元素绑定事件需要用事件代理吗?为什么?

Vue 并没有在源码中做代理

但是一般给 v-for 绑定事件时，都会让节点指向同一个事件处理程序（第二种情况可以运行，但是 eslint 会警告），一定程度上比每生成一个节点都绑定一个不同的事件处理程序性能好，但是监听器的数量仍不会变，所以使用事件代理会更好一点。

---

## vue3

### 1.Vue3.0所采用的Composition Api 与Vue2.x使用的Options Api有什么不同?

Composition API 和 Options API 是Vue.js中的两种组件编写方式。

Options API是Vue.js早期版本中使用的编写方式，通过定义一个options对象进行组件的配置，包括props、data、methods、computed、watch等选项。这种方式的优点在于结构清晰、易于理解，在小型项目中比较实用。

Composition API是Vue.js 3.x版本中新引入的一种组件编写方式，它以函数的形式组织我们的代码，允许我们将相关部分组合起来，提高了代码的可维护性和重用性。Composition API还提供了模块化、类型推断等功能，可以更好地实现面向对象编程的思想。

Composition API 更好的代码组织，更好的逻辑服用；可维护性，更好的类型推导，可拓展性更好；

两种API各有优缺点，使用哪种API取决于具体的项目需求。对于小型项目，Options API更为简单方便；对于大型项目，Composition API可以更好地组织代码。

总之，Vue.js的Composition API和Options API是为了满足不同开发者的需求而存在的，我们应该根据具体的场景选择使用哪种API，以达到更好的开发效果和代码质量。

---

### 2.vue3.0的设计目标是什么?做了哪些优化

[参考](https://vue3js.cn/interview/vue3/goal.html)

---

### 3.用Vue3.0写过组件吗?如果想实现一个Modal你会怎么设计?

[参考](https://vue3js.cn/interview/vue3/modal_component.html)

---

### 4.vue3.0性能提升主要是通过哪几方面体现的?

[参考](https://vue3js.cn/interview/vue3/performance.html)

---

### 5.Vue3.0里为什么要用Proxy API替代defineProperty APl?

[参考](https://vue3js.cn/interview/vue3/proxy.html)

---

### 6.说说Vue 3.0中Treeshaking特性?举例说明—下?

[参考](https://vue3js.cn/interview/vue3/treeshaking.html)

---

### 7.vue2和vue3的生命周期对比？

Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：

- beforeDestroy改名为 beforeUnmount
- destroyed改名为 unmounted

Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：

- beforeCreate===>setup()
- created=======>setup()
- beforeMount ===>onBeforeMount
- mounted=======>onMounted
- beforeUpdate===>onBeforeUpdate
- updated =======>onUpdated
- beforeUnmount ==>onBeforeUnmount
- unmounted =====>onUnmounted

---

### 8.vue3的常用 Composition API有哪些？

1. setup
2. ref函数
3. reactive函数
4. computed函数
5. watch函数
6. watchEffect函数
7. toRef
8. shallowReactive 与 shallowRef
9. readonly 与 shallowReadonly
10. readonly: 让一个响应式数据变为只读的（深只读）。
11. shallowReadonly：让一个响应式数据变为只读的（浅只读）。
12. toRaw 与 markRaw
13. customRef
14. provide 与 inject

---

### 9.Vue3.0有什么更新

**性能优化**：Vue.js 3.0使用了Proxy替代Object.defineProperty实现响应式，并且使用了静态提升技术来提高渲染性能。新增了编译时优化，在编译时进行模板静态分析，并生成更高效的渲染函数。

**Composition API**：Composition API是一个全新的组件逻辑复用方式，可以更好地组合和复用组件的逻辑。

**TypeScript支持**：Vue.js 3.0完全支持TypeScript，在编写Vue应用程序时可以更方便地利用TS的类型检查和自动补全功能。

**新的自定义渲染API**：Vue.js 3.0的自定义渲染API允许开发者在细粒度上控制组件渲染行为，包括自定义渲染器、组件事件和生命周期等。

**改进的Vue CLI**：Vue.js 3.0使用了改进的Vue CLI，可以更加灵活地配置项目，同时支持Vue.js2.x项目升级到Vue.js 3.0。

**移除一些API**：Vue.js 3.0移除了一些不常用的API，如过渡相关API，部分修饰符等。

---

### 10.Vue3为什么比Vue2快？

**响应式系统优化**：Vue3引入了新的响应式系统，这个系统的设计让Vue3的渲染函数可以在编译时生成更少的代码，这也就意味着在运行时需要更少的代码来处理虚拟DOM。这个新系统的一个重要改进就是提供了一种基于Proxy实现的响应式机制，这种机制为开发人员提供更加高效的API，也减少了一些运行时代码。

**编译优化**：Vue3的编译器对代码进行了优化，包括减少了部分注释、空白符和其他非必要字符的编译，同时也对编译后的代码进行了懒加载优化。

**更快的虚拟DOM**：Vue3对虚拟DOM进行了优化，使用了跟React类似的Fiber算法，这样可以更加高效地更新DOM节点，提高性能。

**Composition API**：Vue3引入了Composition API，这种API通过提供逻辑组合和重用的方法来提升代码的可读性和重用性。这种API不仅可以让Vue3应用更好地组织和维护业务逻辑，还可以让开发人员更加轻松地实现优化。

---

## vuex

### 1.vuex是什么? 怎么使用? 哪种功能场景使用它?

Vuex是一个用于管理Vue.js应用程序状态的状态管理库。它将应用程序的状态存储在一个中央的地方，并以响应式的方式进行更新。通过使用Vuex，开发者可以更方便地在不同组件间共享和修改状态。

要使用Vuex，首先要安装和引入它。可以使用npm或者yarn进行安装：

```bash showLineNumbers copy
npm install vuex
# 或者
yarn add vuex
```

然后在Vue.js应用程序的入口文件中引入Vuex，并将其作为Vue的插件来使用：

```js showLineNumbers copy
import Vue from 'vue'
import Vuex from 'vuex'
 
Vue.use(Vuex)
```

接下来，需要创建一个Vuex store实例，用于存储和管理应用程序的状态：

```js showLineNumbers copy
const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment(state) {
      state.count++
    }
  },
  actions: {
    increment(context) {
      context.commit('increment')
    }
  },
  getters: {
    doubleCount(state) {
      return state.count * 2
    }
  }
})
```

在上面的例子中，我们定义了一个包含count状态的state，以及一个用于修改count状态的mutation，还有一个用于触发mutation的action，以及一个用于获取派生状态的getter。

最后，通过在Vue组件中使用Vuex提供的辅助函数（如mapState、mapMutations、mapActions、mapGetters等），可以方便地在组件中访问和修改状态。

**Vuex适用于以下场景：**

- 多个组件需要共享和修改同一个状态。
- 需要在状态发生变化时进行响应式更新。
- 需要对状态进行一些处理或计算，以生成派生状态（如计算属性）。
- 需要对状态的变化进行一些异步操作（如发起AJAX请求）。

总之，Vuex提供了一种统一的方式来管理应用程序的状态，使得开发者能够更好地组织和维护状态逻辑。

---

### 2.Vuex有哪几种属性？

有五种，分别是 State、 Getter、Mutations 、Actions、 Modules

- state => 基本数据(数据源存放地)
- getters => 从基本数据派生出来的数据
- mutations => 提交更改数据的方法，同步
- actions => 像一个装饰器，包裹mutations，使之可以异步。
- modules => 模块化Vuex

**各模块在流程中的功能**

- Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。
- dispatch：操作行为触发方法，是唯一能执行action的方法。
- actions：操作行为处理模块,由组件中的$store.dispatch('action 名称', data1)来触发。然后由commit()来触发mutation的调用 , 间接更新 state。可以定义异步函数，并在回调中提交mutation,就相当于异步更新了state中的字段
- commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。
- mutations：状态改变操作方法，由actions中的commit('mutation 名称')来触发。是Vuex修改state的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。
- state：state中存放页面共享的状态字段
- getters：相当于当前模块state的计算属性

### 2.为什么Vuex的mutation和 Redux 的reducer中不能做异步

- 每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。
- action 可以进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）

---

### 3.Vuex的store特性是什么

- vuex就是一个仓库，仓库里放了很多对象，其中state就是数据源存放地，对应与一般vue对象里面的data
- state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新
- 它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性

### 4.vuex 的 getter 特性是什么

- getter 可以对 state 进行计算操作，它就是 store 的计算属性
- 虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用
- 如果一个状态只在一个组件内使用，是可以不用 getters

---

### 5.vuex 的 mutation 特性是什么

- action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态
- action 可以包含任意异步操作 

---

### 6.vuex的state、getter、mutation、action、module特性分别是什么？

- state：存放公共数据的地方
- getter：获取根据业务场景处理返回的数据
- mutations：唯一修改state的方法，修改过程是同步的
- action：异步处理，通过分发操作触发mutation
- module：将store模块分割，减少代码臃肿

---

### 7.你觉得要是不用vuex的话会带来哪些问题 

- 组件之间传值麻烦复杂
- 可维护性会下降，你要修改数据，你得维护 3 个地方
- 可读性下降，因为一个组件里的数据，你根本就看不出来是从哪里来的
- 增加耦合，大量的上传派发，会让耦合性大大的增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背

---



## vue-router

### 1.vue-router 是什么?它有哪些组件？

vue-router 是 Vue.js 官方的路由管理器，它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：

- 嵌套的路由
- 模块化的、基于组件的路由配置
- 路由参数、查询、通配符
- 基于 Vue.js 过度系统的视图过渡效果
- 细颗粒度的导航控制
- 带有自动激活的 CSS class 的连接
- history模式或 hash 模式，在 IE9 中自动降级
- 自定义的滚动条行为

**vue-router 组件：**

- `<router-link to="">` 路由的路径
- `<router-link :to="{name:’‘l路由名’}">` 命名路由
- `<router-view>` 路由的显示

---

### 2.active-class 是哪个组件的属性？

active-class 属于vue-router的样式方法，当routerlink标签被点击时将会应用这个样式。

**使用方法一：routerLink标签内使用**

```html showLineNumbers copy
<router-link to='/' active-class="active" >首页</router-link>
```

**使用方法二：在路由js文件,配置active-class**

```js showLineNumbers copy
const router = new VueRouter({
  routes,
  linkActiveClass: 'active'
});
```

在使用时会有一个bug：首页的active会一直被应用

为了解决上面的问题，还需加入一个属性exact，也有两种方式。

**方式一：在router-link中写入exact**

```html showLineNumbers copy
<router-link to='/' active-class="active" exact>首页</router-link>
```

**方式二：在路由js文件,配置active-class**

```js showLineNumbers copy
const router = new VueRouter({
  routes,
  linkExactActiveClass: 'active'
});
```

### 3.怎么定义 vue-router 的动态路由? 怎么获取传过来的值？

可以通过query ,param两种方式，区别：query通过url传参，刷新页面参数还在，params刷新页面参数不在了。

**param的类型：**

- 配置路由格式:/router/:id
- 传递的方式:在path后面跟上对应的值
- 传递后形成的路径:/router/123

```js showLineNumbers copy
// 定义路由
{
  path: '/user/:userid',
  component: User,
},
```

```html showLineNumbers copy
<!-- 动态路由-params -->
<router-link :to="'/user/'+userId" replace>用户</router-link>
```

跳转方法：

```html showLineNumbers copy
<!-- 方法1：-->
<router-link :to="{ name: 'users', params: { uname: wade }}">按钮</router-link>
```

```js showLineNumbers copy
// 方法2：
this.$router.push({name:'users',params:{uname:wade}})
```

```js showLineNumbers copy
// 方法3：
this.$router.push('/user/' + wade)
```

通过$route.params.参数名 获取你所传递的值

**query的类型：**

- 配置路由格式:/router,也就是普通配置
- 传递的方式:对象中使用query的key作为传递方式
- 传递后形成的路径:/route?id=123

```html showLineNumbers copy
<!--动态路由-query -->
<!--01-直接在router-link 标签上以对象的形式-->
<router-link :to="{path:'/profile',query:{name:'why',age:28,height:188}}">档案</router-link>
```

```vue showLineNumbers copy
<tempalte>
  <button @click='profileClick'>我的</button>
</tempalte>
<script>
  export default {
    methods: {
      profileClick(){
        this.$router.push({
          path: "/profile",
          query: {
            name: "kobi",
            age: "28",
            height: 198
          }
        });
      }
    }
  }
</script>
```

跳转方法:

方法1：
```html showLineNumbers copy
<router-link :to="{ name: 'users', query: { uname: james }}">按钮</router-link>
```

方法2：
```js showLineNumbers copy
this.$router.push({ name: 'users', query:{ uname:james }})
```

方法3：
```html showLineNumbers copy
<router-link :to="{ path: '/user', query: { uname:james }}">按钮</router-link>
```

方法4：
```js showLineNumbers copy
this.$router.push({ path: '/user', query:{ uname:james }})
```

方法5：
```js showLineNumbers copy
this.$router.push('/user?uname=' + jsmes)
```

通过$route.query 获取你所传递的值

### 4.vue-router 有哪几种导航钩子（导航守卫）?

**第一种：全局导航钩子**

1.前置钩子 `beforeEach`

```js showLineNumbers copy
//单独设置每个路由的属性：
const routes = [
  {
    path: '/login',
    name: 'login',
    component: Login,
    meta: {
      may: true
    }
  }
]

router.beforeEach((to, from, next) => {
  if (to.matched.some(item => item.meta.may)) {
    let id = window.localStorage.getItem("id")
    if (id) {
      next()
    } else {
      next({ name: "login" })
    }
  } else {
    next()
  }
})
```

>注意：next 方法必须要调用，否则钩子函数无法 resolved

2.后置钩子 `afterEach`

```js showLineNumbers copy
router.afterEach((to,from) => {
	if(to.meta && to.meta.title){
		document.title = to.meta.title
	}else{
		document.title = "666"
	}
})
```

**第二种：单独路由独享钩子**

```js showLineNumbers copy
{
  path: '/home',
  name: 'home',
  component: Home,
  beforeEnter(to, from, next) {
    if (window.localStorage.getItem("id")) {
      next()
    } else {
      next({ name: "login" })
    }
  }
}
```

**第三种：组件内的钩子**

```js showLineNumbers copy
beforeRouteEnter(to, from, next) {
  // do someting
  // 在渲染该组件的对应路由被 confirm 前调用
},
beforeRouteUpdate(to, from, next) {
  // do someting
  // 在当前路由改变，但是依然渲染该组件是调用
},
beforeRouteLeave(to, from ,next) {
  // do someting
  // 导航离开该组件的对应路由时被调用
}
```

**全局解析守卫**

router.beforeResolve 注册一个全局守卫，和 router.beforeEach 类似

可以在src目录下新建一个permission.js文件

```js showLineNumbers copy
import router from './router'
import store from './store'
import { Message } from 'element-ui'
import NProgress from 'nprogress'
import 'nprogress/nprogress.css'
import { getToken } from '@/utils/auth'

NProgress.configure({ showSpinner: false })

const whiteList = ['/login', '/auth-redirect', '/bind', '/register']

router.beforeEach((to, from, next) => {
  NProgress.start()
  if (getToken()) {
    /* has token*/
    if (to.path === '/login') {
      next({ path: '/' })
      NProgress.done()
    } else {
      if (store.getters.roles.length === 0) {
        // 判断当前用户是否已拉取完user_info信息
        store.dispatch('GetInfo').then(res => {
          // 拉取user_info
          const roles = res.roles
          store.dispatch('GenerateRoutes', { roles }).then(accessRoutes => {
          // 测试 默认静态页面
          // store.dispatch('permission/generateRoutes', { roles }).then(accessRoutes => {
            // 根据roles权限生成可访问的路由表
            router.addRoutes(accessRoutes) // 动态添加可访问路由表
            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成
          })
        })
          .catch(err => {
            store.dispatch('FedLogOut').then(() => {
              Message.error(err)
              next({ path: '/' })
            })
          })
      } else {
        next()
        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓
        // if (hasPermission(store.getters.roles, to.meta.roles)) {
        //   next()
        // } else {
        //   next({ path: '/401', replace: true, query: { noGoBack: true }})
        // }
        // 可删 ↑
      }
    }
  } else {
    // 没有token
    if (whiteList.indexOf(to.path) !== -1) {
      // 在免登录白名单，直接进入
      next()
    } else {
      next(`/login?redirect=${to.fullPath}`) // 否则全部重定向到登录页
      NProgress.done()
    }
  }
})

router.afterEach(() => {
  // 进度条
  NProgress.done()
})
```

### 5.$route 和 $router 的区别

**$route对象**：$route对象表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等。

```
1. $route.path 字符串，对应当前路由的路径，总是解析为绝对路径，如"/foo/bar"。
2. $route.params 一个 key/value 对象，包含了 动态片段 和 全匹配片段， 如果没有路由参数，就是一个空对象。
3. $route.query 一个 key/value 对象，表示 URL 查询参数。 例如，对于路径 /foo?user=1，则有$route.query.user == 1， 如果没有查询参数，则是个空对象。
4. $route.hash 当前路由的hash值 (不带#) ，如果没有 hash 值，则为空字符串。锚点*
5. $route.fullPath 完成解析后的 URL，包含查询参数和hash的完整路径。
6. $route.matched 数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。
7. $route.name 当前路径名字
8. $route.meta 路由元信息
```

**$router对象**：$router对象是全局路由的实例，是router构造方法的实例。

实例方法：

**1、push**

1. 字符串`this.$router.push('home')`
2. 对象`this.$router.push({ path: 'home'})`
3. 命名的路由`this.$router.push({name:'user',params:{userId:123}})`
4.带查询参数，变成 /register?plan=123 -> `this.$router.push({path:'register',query:{plan:'123'}})`

push方法其实和`<router-link :to="...">`是等同的。

>注意：push方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。

**2、go**

页面路由跳转
前进或者后退this.$router.go(-1) // 后退

**3、replace**

push方法会向 history 栈添加一个新的记录，而replace方法是替换当前的页面，
不会向 history 栈添加一个新的记录

---

### 6.vue-router响应路由参数的变化？

当使用路由参数时，例如从 /user/aside导航到 /user/foo，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。

注意:

（1）从同一个组件跳转到同一个组件。

（2）生命周期钩子created和mounted都不会调用。

```js showLineNumbers copy
beforeRouteUpdate(to,from,next){
  // 在这个钩子函数中：to表示将要跳转的路由对象，from表示从哪个路由跳转过来，next多数就是需要调用
  // created和mounted不调用，无法拿到需要的动态值，就通过to.path,to.params等
  // 可以在这个函数中打印to，具体看to对象有什么可以使用的属性
}
```

添加watch监听

```js showLineNumbers copy
watch: {
 // 方法1 //监听路由是否变化
  '$route' (to, from) {
   if(to.query.id !== from.query.id){
      this.id = to.query.id;
      // 重新加载数据
      this.init();
    }
  }
}
//方法 2  设置路径变化时的处理函数
watch: {
'$route': {
    handler: 'init',
    immediate: true
  }
}
```

为了实现这样的效果可以给router-view添加一个不同的key，这样即使是公用组件，只要url变化了，就一定会重新创建这个组件。

```html showLineNumbers copy
<router-view :key="$route.fullpath"></router-view>
```

---

### 7.vue项目实现路由按需加载(路由懒加载)的3种方式

**1.vue异步组件技术**

```js showLineNumbers copy
/* vue异步组件技术 */
{
  path: '/home',
  name: 'home',
  component: resolve => require(['@/components/home'],resolve)
},{
  path: '/index',
  name: 'Index',
  component: resolve => require(['@/components/index'],resolve)
},{
  path: '/about',
  name: 'about',
  component: resolve => require(['@/components/about'],resolve)
} 
```

**2.路由懒加载(使用import)**

```js showLineNumbers copy
// 下面2行代码，没有指定webpackChunkName，每个组件打包成一个js文件。
/*
const Home = () => import('@/components/home')
const Index = () => import('@/components/index')
const About = () => import('@/components/about')
*/

// 下面2行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。 把组件按组分块
const Home =  () => import(/* webpackChunkName: 'ImportFuncDemo' */ '@/components/home')
const Index = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '@/components/index')
const About = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '@/components/about')
```

**webpack提供的require.ensure()**

vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。
这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。

```js showLineNumbers copy
/* 组件懒加载方案三: webpack提供的require.ensure() */
{
  path: '/home',
  name: 'home',
  component: r => require.ensure([], () => r(require('@/components/home')), 'demo')
}, {
  path: '/index',
  name: 'Index',
  component: r => require.ensure([], () => r(require('@/components/index')), 'demo')
}, {
  path: '/about',
  name: 'about',
  component: r => require.ensure([], () => r(require('@/components/about')), 'demo-01')
}
```

---

### 8.路由的history和hash

Vue-Router主要有两种模式：Hash模式和 History模式。这两种模式的主要区别在于它们如何处理url以及如何更新页面的内容。

**Hash模式**：这是VueRouter的默认模式。它的工作原理是利用`hashchange`事件监听URL中的`#`符号的变化。在这个模式下，URL的变化不会导致页面的刷新，而是通过监听hashchange事件来实现路由的切换。这样的设计使得页面只在首次加载时刷新，而在后续的导航过程中，只要URL发生变化，就会显示最新的内容，而不必完全重载页面。

**History模式**：在这种模式下，Vue单页面应用不会刷新页面。它是基于HTML5的新特性`history`实现的，允许用户在浏览器历史记录栈中操作，如前进、后退等。通过这种方式，无论是在开发还是生产环境，都可以实现无刷新地切换页面

此外，Vue-Router还提供了一种抽象模式，这种模式不依赖于具体的浏览器环境，而是在非浏览器环境中使用，如Node.js的服务器端渲染

---

### 9.vue-router跳转和location.href有什么区别

- 使用location跳转简单方便，但是刷新了页面
- 使用history.pushState('/url')无刷新页面，静态跳转
- 引进router，然后使用router.push('/url')来跳转，使用了diff算法，实现了按需加载，减少了Dom的消耗